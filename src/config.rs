use cidr::Ipv4Inet;
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::prelude::*;
use std::net::Ipv4Addr;

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone, Default)]
pub struct Config {
    pub filters: Filters,
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct Filters {
    #[serde(default)]
    pub blacklist: Vec<Ipv4Inet>,
    #[serde(default)]
    pub whitelist: Vec<Ipv4Inet>,
    #[serde(default)]
    pub redirect: Vec<Redirect>,
    pub rate_limit: Option<RateLimit>,
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct Redirect {
    #[serde(default = "Redirect::default_ip")]
    pub from_ip: Ipv4Inet,
    pub from_port: Option<u16>,
    pub to_ip: Ipv4Addr,
    pub to_port: Option<u16>,
    pub chance: f32,
}

impl Redirect {
    pub fn default_ip() -> Ipv4Inet {
        Ipv4Inet::new(Ipv4Addr::new(0, 0, 0, 0), 0).unwrap()
    }
}

impl Default for Redirect {
    fn default() -> Self {
        Redirect {
            from_ip: Redirect::default_ip(),
            from_port: None,
            to_ip: Ipv4Addr::UNSPECIFIED,
            to_port: None,
            chance: 1.0,
        }
    }
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct RateLimit {
    pub period: u64,
    pub host_connections: u32,
    pub host_port_connections: u32,
    pub host_dst_connections: u32,
}

impl Config {
    pub fn load() -> Config {
        let mut file = File::open("config.yaml").unwrap();
        let mut contents = String::new();
        file.read_to_string(&mut contents).unwrap();

        let config: Config = serde_yaml::from_str(&contents).unwrap_or_else(|e| {
            panic!("Error parsing config file: {}", e);
        });
        println!("{:#?}", config);
        return config;
    }
}

impl Default for Filters {
    fn default() -> Self {
        Filters {
            blacklist: Vec::new(),
            whitelist: Vec::new(),
            redirect: Vec::new(),
            rate_limit: None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::net::Ipv4Addr;

    #[test]
    fn test_parse_config() {
        let yaml = r#"
filters:
  blacklist:
    - 192.168.1.1/24
  whitelist:
    - 192.168.1.100
  redirect:
    - from_ip: 8.8.8.8
      to_ip: 1.1.1.1
      chance: 0.5
  rate_limit:
    period: 10000
    host_connections: 10
    host_port_connections: 5
    host_dst_connections: 5
"#;

        let config: Config = serde_yaml::from_str(yaml).unwrap();

        let expected_blacklist = vec![Ipv4Inet::new(Ipv4Addr::new(192, 168, 1, 1), 24).unwrap()];
        assert_eq!(config.filters.blacklist, expected_blacklist);

        let expected_whitelist = vec![Ipv4Inet::new(Ipv4Addr::new(192, 168, 1, 100), 32).unwrap()];
        assert_eq!(config.filters.whitelist, expected_whitelist);

        let expected_redirect = vec![Redirect {
            from_ip: Ipv4Inet::new(Ipv4Addr::new(8, 8, 8, 8), 32).unwrap(),
            to_ip: Ipv4Addr::new(1, 1, 1, 1),
            chance: 0.5,
            ..Default::default()
        }];
        assert_eq!(config.filters.redirect, expected_redirect);

        let expected_rate_limit = RateLimit {
            period: 10000,
            host_connections: 10,
            host_port_connections: 5,
            host_dst_connections: 5,
        };
        assert_eq!(config.filters.rate_limit.unwrap(), expected_rate_limit);
    }

    #[test]
    fn test_parse_config_empty() {
        let yaml = r#"
filters:
"#;
        let config: Config = serde_yaml::from_str(yaml).unwrap();
        assert_eq!(config.filters.blacklist.len(), 0);
        assert_eq!(config.filters.whitelist.len(), 0);
        assert_eq!(config.filters.redirect.len(), 0);
        assert_eq!(config.filters.rate_limit, None);
    }
}
