use cidr::Ipv4Inet;
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::prelude::*;
use std::net::Ipv4Addr;

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone, Default)]
pub struct Config {
    pub filters: Filters,
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct Filters {
    #[serde(default)]
    pub filterlist: Vec<Filter>,
    #[serde(default)]
    pub redirect: Vec<Redirect>,
    pub rate_limit: Option<RateLimit>,
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct Filter {
    #[serde(default = "Filter::default_allow")]
    pub allow: bool,
    #[serde(default = "Filter::default_ip")]
    pub ip: Ipv4Inet,
    #[serde(default)]
    pub port: Option<u16>,
}

impl Filter {
    pub fn default_allow() -> bool {
        false
    }

    pub fn default_ip() -> Ipv4Inet {
        Ipv4Inet::new(Ipv4Addr::new(0, 0, 0, 0), 0).unwrap()
    }
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct Redirect {
    #[serde(default = "Redirect::default_ip")]
    pub from_ip: Ipv4Inet,
    pub from_port: Option<u16>,
    pub to_ip: Ipv4Addr,
    pub to_port: Option<u16>,
    pub chance: f32,
}

impl Redirect {
    pub fn default_ip() -> Ipv4Inet {
        Ipv4Inet::new(Ipv4Addr::new(0, 0, 0, 0), 0).unwrap()
    }
}

impl Default for Redirect {
    fn default() -> Self {
        Redirect {
            from_ip: Redirect::default_ip(),
            from_port: None,
            to_ip: Ipv4Addr::UNSPECIFIED,
            to_port: None,
            chance: 1.0,
        }
    }
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct RateLimit {
    pub period: u64,
    pub host_connections: u32,
    pub host_port_connections: u32,
    pub host_dst_connections: u32,
    pub tcp_period: u64,
    pub tcp_handshakes: u32,
}

impl Config {
    pub fn load() -> Config {
        let mut file = File::open("config.yaml").unwrap();
        let mut contents = String::new();
        file.read_to_string(&mut contents).unwrap();

        let config: Config = serde_yaml::from_str(&contents).unwrap_or_else(|e| {
            panic!("Error parsing config file: {}", e);
        });
        println!("{:#?}", config);
        return config;
    }
}

impl Default for Filters {
    fn default() -> Self {
        Filters {
            filterlist: Vec::new(),
            redirect: Vec::new(),
            rate_limit: None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::net::Ipv4Addr;

    #[test]
    fn test_parse_config() {
        let yaml = r#"
filters:
  filterlist:
    - allow: true
      ip: 192.168.1.1/24
    - ip: 192.168.1.100
    - port: 22
  redirect:
    - from_ip: 8.8.8.8
      to_ip: 1.1.1.1
      chance: 0.5
  rate_limit:
    period: 10000
    host_connections: 20
    host_port_connections: 5
    host_dst_connections: 5
    tcp_period: 100
    tcp_handshakes: 1
"#;

        let config: Config = serde_yaml::from_str(yaml).unwrap();

        let expected_filterlist = vec![
            Filter {
                allow: true,
                ip: Ipv4Inet::new(Ipv4Addr::new(192, 168, 1, 1), 24).unwrap(),
                port: None,
            },
            Filter {
                allow: false,
                ip: Ipv4Inet::new(Ipv4Addr::new(192, 168, 1, 100), 32).unwrap(),
                port: None,
            },
            Filter {
                allow: false,
                ip: Ipv4Inet::new(Ipv4Addr::new(0, 0, 0, 0), 0).unwrap(),
                port: Some(22),
            },
        ];
        assert_eq!(config.filters.filterlist, expected_filterlist);

        let expected_redirect = vec![Redirect {
            from_ip: Ipv4Inet::new(Ipv4Addr::new(8, 8, 8, 8), 32).unwrap(),
            to_ip: Ipv4Addr::new(1, 1, 1, 1),
            chance: 0.5,
            ..Default::default()
        }];
        assert_eq!(config.filters.redirect, expected_redirect);

        let expected_rate_limit = RateLimit {
            period: 10000,
            host_connections: 20,
            host_port_connections: 5,
            host_dst_connections: 5,
            tcp_period: 100,
            tcp_handshakes: 1,
        };
        assert_eq!(config.filters.rate_limit.unwrap(), expected_rate_limit);
    }

    #[test]
    fn test_parse_config_empty() {
        let yaml = r#"
filters:
"#;
        let config: Config = serde_yaml::from_str(yaml).unwrap();
        assert_eq!(config.filters.filterlist.len(), 0);
        assert_eq!(config.filters.redirect.len(), 0);
        assert_eq!(config.filters.rate_limit, None);
    }
}
