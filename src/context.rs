use std::sync::{Mutex, RwLock};

use crate::config::Config;
use crate::data::flow_cache::FlowCache;
use crate::data::routes::RoutesCache;
use crate::handlers::dns_filter::DnsFilter;
use crate::handlers::ip_list_filter::ListFilter;
use crate::handlers::ip_redirect::IpRedirectFilter;
use crate::handlers::rate_limit::RateLimit;
use crate::handlers::FilterModule;
use std::sync::Arc;

/// Context is a struct that contains all the data that is shared between the different modules.
#[derive(Debug)]
pub struct AppContext {
    pub config: RwLock<Config>,
    pub routes: RwLock<RoutesCache>,
    pub flow_cache: RwLock<FlowCache>,
    pub filters: Mutex<Vec<FilterModule>>,
}

pub type AppContextRef = Arc<AppContext>;

impl AppContext {
    pub fn new(config: Config) -> AppContextRef {
        let ctx = Arc::new(AppContext {
            config: RwLock::new(config),
            routes: RwLock::new(RoutesCache::new()),
            flow_cache: RwLock::new(FlowCache::new()),
            filters: Mutex::new(vec![]),
        });
        // Load the filter modules
        {
            let mut filters = ctx.filters.lock().unwrap();
            filters.push(DnsFilter::new_module(ctx.clone()));
            filters.push(IpRedirectFilter::new_module(ctx.clone()));
            filters.push(ListFilter::new_module(ctx.clone()));
            filters.push(RateLimit::new_module(ctx.clone()));
        }
        return ctx;
    }
}
