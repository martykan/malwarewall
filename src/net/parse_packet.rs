use etherparse::Ethernet2Header;
use etherparse::InternetSlice::*;
use etherparse::IpHeader;
use etherparse::LinkSlice::*;
use etherparse::PacketBuilder;
use etherparse::PacketBuilderStep;
use etherparse::SlicedPacket;
use etherparse::TransportSlice::*;
use std::net::Ipv4Addr;

use crate::constants::MY_MAC;
use crate::context::AppContextRef;
use crate::data::flow_cache::FlowProtocol;
use crate::handlers::FilterModule;
use crate::handlers::IpFilterRequest;
use crate::net::arp::handle_arp;
use crate::types::OutputMode;

/// Rewrite the IP address based on routes
fn rewrite_ip(ctx: AppContextRef, ip: Ipv4Addr, is_source: bool) -> Ipv4Addr {
    if let Some(route) = ctx.routes.read().unwrap().get_route(ip) {
        if is_source {
            return route.rewrite_ip;
        } else {
            return route.ip;
        }
    }
    return ip;
}

struct HandlePacketResponse {
    builder: Option<PacketBuilderStep<IpHeader>>,
    src_port: u16,
    dst_port: u16,
    src_ip: Ipv4Addr,
    dst_ip: Ipv4Addr,
}

impl HandlePacketResponse {
    fn drop() -> Self {
        Self {
            builder: None,
            src_port: 0,
            dst_port: 0,
            src_ip: Ipv4Addr::UNSPECIFIED,
            dst_ip: Ipv4Addr::UNSPECIFIED,
        }
    }
}

fn handle_packet(
    ctx: AppContextRef,
    outbound: bool,
    eth_builder: Option<PacketBuilderStep<Ethernet2Header>>,
    original_src_ip: Ipv4Addr,
    original_dst_ip: Ipv4Addr,
    protocol: FlowProtocol,
    src_port: u16,
    dst_port: u16,
    payload_length: usize,
) -> HandlePacketResponse {
    let mut src_ip = rewrite_ip(ctx.clone(), original_src_ip, true).octets();
    let mut dst_ip = rewrite_ip(ctx.clone(), original_dst_ip, false).octets();
    let mut src_port = src_port;
    let mut dst_port = dst_port;

    // Run filter modules
    for filter in ctx.filters.lock().unwrap().iter() {
        let ip_filter = match filter {
            FilterModule::Ip(ip_filter) => ip_filter,
            _ => continue,
        };
        let res = ip_filter.ip_filter(&IpFilterRequest {
            src_ip: original_src_ip,
            dst_ip: original_dst_ip,
            src_port,
            dst_port,
        });
        if let Some(new_src_ip) = res.new_src_ip {
            src_ip = new_src_ip.octets();
        }
        if let Some(new_dst_ip) = res.new_dst_ip {
            dst_ip = new_dst_ip.octets();
        }
        if let Some(new_src_port) = res.new_src_port {
            src_port = new_src_port;
        }
        if let Some(new_dst_port) = res.new_dst_port {
            dst_port = new_dst_port;
        }
        if res.end {
            break;
        }
    }

    let builder;
    let flow_src_ip;
    let flow_dst_ip;
    let middlebox_ip;
    match eth_builder {
        Some(eth_builder) => {
            // Inbound packet
            builder = eth_builder.ipv4(src_ip, dst_ip, 64);
            flow_src_ip = Ipv4Addr::from(dst_ip);
            flow_dst_ip = Ipv4Addr::from(src_ip);
            middlebox_ip = original_dst_ip;
        }
        None => {
            // Outbound packet
            builder = PacketBuilder::ipv4(src_ip, dst_ip, 64);
            flow_src_ip = original_src_ip;
            flow_dst_ip = original_dst_ip;
            middlebox_ip = Ipv4Addr::from(src_ip);
        }
    }
    {
        ctx.flow_cache.write().unwrap().log_packet(
            outbound,
            flow_src_ip,
            flow_dst_ip,
            middlebox_ip,
            protocol,
            if outbound { src_port } else { dst_port },
            if outbound { dst_port } else { src_port },
            payload_length,
        );
    }
    if dst_ip == Ipv4Addr::UNSPECIFIED.octets() || src_ip == Ipv4Addr::UNSPECIFIED.octets() {
        return HandlePacketResponse::drop();
    }
    return HandlePacketResponse {
        builder: Some(builder),
        src_port,
        dst_port,
        src_ip: flow_src_ip,
        dst_ip: flow_dst_ip,
    };
}

fn parse_packet_l3(
    ctx: AppContextRef,
    value: SlicedPacket,
    eth_builder: Option<PacketBuilderStep<Ethernet2Header>>,
) -> (OutputMode, Option<Vec<u8>>) {
    let outbound = eth_builder.is_none();
    let packet_len;
    let original_src_ip;
    let original_dst_ip;
    match value.ip.unwrap() {
        Ipv4(header, _extension) => {
            print!("IPv4 src: {:?} ", header.source_addr().to_string());
            print!("IPv4 dst: {:?} ", header.destination_addr().to_string());
            packet_len = header.payload_len() as usize;
            original_src_ip = header.source_addr();
            original_dst_ip = header.destination_addr();
        }
        Ipv6(header, _extension) => {
            print!("IPv6 src: {:?} ", header.source_addr().to_string());
            print!("IPv6 dst: {:?} ", header.destination_addr().to_string());
            // IPv6 not implemented currently
            return (OutputMode::DROP, None);
        }
    }
    match value.transport.unwrap() {
        Icmpv4(data) => {
            print!("ICMPv4: {:?} ", data.icmp_type());
            let res = handle_packet(
                ctx,
                outbound,
                eth_builder,
                original_src_ip,
                original_dst_ip,
                FlowProtocol::ICMP,
                0,
                0,
                0,
            );
            if res.builder.is_none() {
                return (OutputMode::DROP, None);
            }
            let builder = res.builder.unwrap().icmpv4(data.icmp_type());
            let mut result = Vec::<u8>::with_capacity(builder.size(data.payload().len()));
            builder.write(&mut result, data.payload()).unwrap();
            return (OutputMode::FORWARD, Some(result));
        }
        Tcp(data) => {
            print!(
                "TCP: port src {:?} dst {:?} seq {:?} ",
                data.source_port(),
                data.destination_port(),
                data.sequence_number()
            );
            let payload_length = packet_len - 4 * (data.data_offset() as usize);
            println!("payload length: {:?} ", payload_length);
            let res = handle_packet(
                ctx.clone(),
                outbound,
                eth_builder,
                original_src_ip,
                original_dst_ip,
                FlowProtocol::TCP,
                data.source_port(),
                data.destination_port(),
                payload_length,
            );
            if res.builder.is_none() {
                return (OutputMode::DROP, None);
            }
            let mut builder = res
                .builder
                .unwrap()
                .tcp(
                    res.src_port,
                    res.dst_port,
                    data.sequence_number(),
                    data.window_size(),
                )
                .options_raw(data.options())
                .unwrap();
            {
                // Log TCP flags
                ctx.flow_cache.write().unwrap().log_tcp(
                    outbound,
                    res.src_ip,
                    res.dst_ip,
                    res.src_port,
                    res.dst_port,
                    &data,
                );
            }
            if data.ack() {
                print!("ACK ");
                builder = builder.ack(data.acknowledgment_number());
            }
            if data.syn() {
                print!("SYN ");
                builder = builder.syn();
            }
            if data.fin() {
                print!("FIN ");
                builder = builder.fin();
            }
            if data.psh() {
                print!("PSH ");
                builder = builder.psh();
            }
            if data.rst() {
                print!("RST ");
                builder = builder.rst();
            }
            if data.urg() {
                print!("URG ");
                builder = builder.urg(data.urgent_pointer());
            }
            if data.ns() {
                print!("NS ");
                builder = builder.ns();
            }
            if data.cwr() {
                print!("CWR ");
                builder = builder.cwr();
            }
            if data.ece() {
                print!("ECE ");
                builder = builder.ece();
            }
            let payload = &value.payload[..payload_length].to_vec();
            let payload_string = String::from_utf8_lossy(payload);
            println!("payload string: {:?}", payload_string);
            let mut result = Vec::<u8>::with_capacity(builder.size(payload.len()));
            builder.write(&mut result, &payload).unwrap();
            return (OutputMode::FORWARD, Some(result));
        }
        Udp(data) => {
            print!(
                "UDP: port src {:?} dst {:?} size {:?} ",
                data.source_port(),
                data.destination_port(),
                data.length(),
            );
            let payload_length = data.length() as usize;
            println!("payload length: {:?} ", payload_length);
            let payload_slice = &value.payload[0..payload_length];
            let res = handle_packet(
                ctx,
                outbound,
                eth_builder,
                original_src_ip,
                original_dst_ip,
                FlowProtocol::UDP,
                data.source_port(),
                data.destination_port(),
                payload_length,
            );
            if res.builder.is_none() {
                return (OutputMode::DROP, None);
            }
            let builder = res.builder.unwrap().udp(res.src_port, res.dst_port);
            let mut result = Vec::<u8>::with_capacity(builder.size(payload_length));
            builder.write(&mut result, payload_slice).unwrap();
            return (OutputMode::FORWARD, Some(result));
        }
        _ => {
            print!("Unknown ");
        }
    }
    return (OutputMode::DROP, None);
}

/// Parse a packet and print some information about it.
/// Returns false if the packet should be dropped. Otherwise returns true and the modified packet content.
pub fn parse_packet(
    ctx: AppContextRef,
    outbound: bool,
    buf: &[u8],
) -> (OutputMode, Option<Vec<u8>>) {
    if outbound {
        match SlicedPacket::from_ethernet(buf) {
            Err(value) => println!("Err {:?}", value),
            Ok(value) => match value.link.as_ref().unwrap() {
                Ethernet2(ethernet) => {
                    println!(
                        "Ethernet2: {:02x?} -> {:02x?}, type: {:04x?}",
                        ethernet.source(),
                        ethernet.destination(),
                        ethernet.ether_type()
                    );
                    if ethernet.ether_type() == 0x0806 {
                        return handle_arp(buf);
                    }
                    match value.ip.as_ref() {
                        Some(Ipv4(header, _extension)) => {
                            {
                                ctx.routes
                                    .write()
                                    .unwrap()
                                    .add_route(header.source_addr(), ethernet.source());
                            }
                            return parse_packet_l3(ctx, value, None);
                        }
                        _ => {
                            println!("Unsupported network layer");
                            return (OutputMode::DROP, None);
                        }
                    }
                }
            },
        }
    } else {
        match SlicedPacket::from_ip(buf) {
            Err(value) => println!("Err {:?}", value),
            Ok(value) => match value.ip.as_ref() {
                // Find the route entry by the destination IP
                Some(Ipv4(header, _extension)) => {
                    let route;
                    {
                        route = ctx
                            .routes
                            .read()
                            .unwrap()
                            .get_route(header.destination_addr());
                    }
                    match route {
                        Some(route) => {
                            let eth_builder = PacketBuilder::ethernet2(MY_MAC, route.mac);
                            return parse_packet_l3(ctx, value, Some(eth_builder));
                        }
                        None => {
                            println!("No route found");
                            return (OutputMode::DROP, None);
                        }
                    }
                }
                _ => {
                    println!("Unsupported network layer");
                    return (OutputMode::DROP, None);
                }
            },
        }
    }
    return (OutputMode::DROP, None);
}
