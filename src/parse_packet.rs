use etherparse::Ethernet2Header;
use etherparse::InternetSlice::*;
use etherparse::LinkSlice::*;
use etherparse::PacketBuilder;
use etherparse::SlicedPacket;
use etherparse::TransportSlice::*;
use std::net::Ipv4Addr;

#[derive(PartialEq, Eq)]
pub enum OutputMode {
    DROP,
    FORWARD,
    REPLY,
}

/// Rewrite the IP address based on preset rules.
fn rewrite_ip(ip: Ipv4Addr, is_source: bool) -> Ipv4Addr {
    if ip == Ipv4Addr::new(10, 0, 0, 1) && is_source {
        return Ipv4Addr::new(10, 2, 0, 1);
    } else if ip == Ipv4Addr::new(10, 2, 0, 1) && !is_source {
        return Ipv4Addr::new(10, 0, 0, 1);
    } else if ip == Ipv4Addr::new(1, 1, 1, 1) && is_source {
        return Ipv4Addr::new(8, 8, 8, 8);
    } else if ip == Ipv4Addr::new(8, 8, 8, 8) && !is_source {
        return Ipv4Addr::new(1, 1, 1, 1);
    } else {
        return ip;
    }
}

pub fn handle_arp(buf: &[u8]) -> (OutputMode, Option<Vec<u8>>) {
    let packet = SlicedPacket::from_ethernet(buf).unwrap();
    let arp = packet.payload;

    // Parse the ARP header
    // (Interface tap10 is asking for the MAC address of a host on the outside world)
    let header_eth_ipv4 = [00, 01, 08, 00, 06, 04, 00, 01];
    if arp[0..8] != header_eth_ipv4 {
        println!("Unsupported ARP header (not ethernet/IPv4 request)");
        return (OutputMode::DROP, None);
    }
    let sha = [arp[8], arp[9], arp[10], arp[11], arp[12], arp[13]];
    let spa = [arp[14], arp[15], arp[16], arp[17]];
    let tha = [arp[18], arp[19], arp[20], arp[21], arp[22], arp[23]];
    let tpa = [arp[24], arp[25], arp[26], arp[27]];
    println!("SHA: {:02x?}", sha);
    println!("SPA: {:?}", spa);
    println!("THA: {:02x?}", tha);
    println!("TPA: {:0?}", tpa);

    let my_mac = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06];
    let output_eth = Ethernet2Header {
        destination: sha,
        source: my_mac,
        ether_type: 0x0806,
    };
    let output_arp = [
        0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x02, // Header
        my_mac[0], my_mac[1], my_mac[2], my_mac[3], my_mac[4], my_mac[5], // SHA
        tpa[0], tpa[1], tpa[2], tpa[3], // TPA
        tha[0], tha[1], tha[2], tha[3], tha[4], tha[5], // THA
        spa[0], spa[1], spa[2], spa[3], // SPA
    ];
    let mut output = Vec::new();
    output.extend_from_slice(&output_eth.to_bytes());
    output.extend_from_slice(&output_arp);
    return (OutputMode::REPLY, Some(output));
}

/// Parse a packet and print some information about it.
/// Returns false if the packet should be dropped. Otherwise returns true and the modified packet content.
pub fn parse_packet(buf: &[u8]) -> (OutputMode, Option<Vec<u8>>) {
    match SlicedPacket::from_ethernet(buf) {
        Err(value) => println!("Err {:?}", value),
        Ok(value) => {
            let packet_len;
            // TODO rewrite the MAC addresses correctly
            let eth_builder = PacketBuilder::ethernet2([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 5, 2]);
            let builder;
            match value.link.unwrap() {
                Ethernet2(ethernet) => {
                    println!(
                        "Ethernet2: {:02x?} -> {:02x?}, type: {:04x?}",
                        ethernet.source(),
                        ethernet.destination(),
                        ethernet.ether_type()
                    );
                    if ethernet.ether_type() == 0x0806 {
                        return handle_arp(buf);
                    }
                }
                _ => {
                    println!("Unsupported link layer");
                    return (OutputMode::DROP, None);
                }
            }
            if value.ip.is_none() {
                println!("Unsupported network layer");
                return (OutputMode::DROP, None);
            }
            match value.ip.unwrap() {
                Ipv4(header, _extension) => {
                    print!("IPv4 src: {:?} ", header.source_addr().to_string());
                    print!("IPv4 dst: {:?} ", header.destination_addr().to_string());
                    packet_len = header.payload_len() as usize;
                    builder = eth_builder.ipv4(
                        rewrite_ip(header.source_addr(), true).octets(),
                        rewrite_ip(header.destination_addr(), false).octets(),
                        64,
                    );
                }
                Ipv6(header, _extension) => {
                    print!("IPv6 src: {:?} ", header.source_addr().to_string());
                    print!("IPv6 dst: {:?} ", header.destination_addr().to_string());
                    packet_len = header.payload_length() as usize;
                    builder = eth_builder.ipv6(
                        header.source_addr().octets(),
                        header.destination_addr().octets(),
                        64,
                    );
                    // TODO: Implement IPv6
                    return (OutputMode::DROP, None);
                }
            }

            match value.transport.unwrap() {
                Icmpv4(data) => {
                    print!("ICMPv4: {:?} ", data.icmp_type());
                    let builder = builder.icmpv4(data.icmp_type());
                    let mut result = Vec::<u8>::with_capacity(builder.size(data.payload().len()));
                    builder.write(&mut result, data.payload()).unwrap();
                    return (OutputMode::FORWARD, Some(result));
                }
                Icmpv6(data) => {
                    print!("ICMPv6: {:?} ", data.icmp_type());
                    // Not implemented currently
                }
                Tcp(data) => {
                    print!(
                        "TCP: port src {:?} dst {:?} seq {:?} ",
                        data.source_port(),
                        data.destination_port(),
                        data.sequence_number()
                    );
                    let mut builder = builder
                        .tcp(
                            data.source_port(),
                            data.destination_port(),
                            data.sequence_number(),
                            data.window_size(),
                        )
                        .options_raw(data.options())
                        .unwrap();
                    if data.ack() {
                        print!("ACK ");
                        builder = builder.ack(data.acknowledgment_number());
                    }
                    if data.syn() {
                        print!("SYN ");
                        builder = builder.syn();
                    }
                    if data.fin() {
                        print!("FIN ");
                        builder = builder.fin();
                    }
                    if data.psh() {
                        print!("PSH ");
                        builder = builder.psh();
                    }
                    if data.rst() {
                        print!("RST ");
                        builder = builder.rst();
                    }
                    if data.urg() {
                        print!("URG ");
                        builder = builder.urg(data.urgent_pointer());
                    }
                    if data.ns() {
                        print!("NS ");
                        builder = builder.ns();
                    }
                    if data.cwr() {
                        print!("CWR ");
                        builder = builder.cwr();
                    }
                    if data.ece() {
                        print!("ECE ");
                        builder = builder.ece();
                    }

                    let payload_length = packet_len - 4 * (data.data_offset() as usize);
                    println!("payload length: {:?} ", payload_length);
                    let payload = &value.payload[..payload_length].to_vec();
                    //println!("payload: {:?}", payload);
                    let payload_string = String::from_utf8_lossy(payload);
                    println!("payload string: {:?}", payload_string);
                    let mut result = Vec::<u8>::with_capacity(builder.size(payload.len()));
                    builder.write(&mut result, &payload).unwrap();
                    return (OutputMode::FORWARD, Some(result));
                }
                Udp(data) => {
                    print!(
                        "UDP: port src {:?} dst {:?} size {:?} ",
                        data.source_port(),
                        data.destination_port(),
                        data.length(),
                    );
                    let payload_length = data.length() as usize;
                    let payload_slice = &value.payload[0..payload_length];
                    let builder = builder.udp(data.source_port(), data.destination_port());
                    let mut result = Vec::<u8>::with_capacity(builder.size(payload_length));
                    builder.write(&mut result, payload_slice).unwrap();
                    return (OutputMode::FORWARD, Some(result));
                }
                Unknown(_data) => {
                    print!("Unknown ");
                }
            }
        }
    }
    return (OutputMode::DROP, None);
}
