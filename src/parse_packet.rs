use etherparse::InternetSlice::*;
use etherparse::PacketBuilder;
use etherparse::SlicedPacket;
use etherparse::TransportSlice::*;
use std::net::Ipv4Addr;

/// Rewrite the IP address based on preset rules.
fn rewrite_ip(ip: Ipv4Addr, is_source: bool) -> Ipv4Addr {
    if ip == Ipv4Addr::new(10, 0, 0, 1) && is_source {
        return Ipv4Addr::new(10, 2, 0, 1);
    } else if ip == Ipv4Addr::new(10, 2, 0, 1) && !is_source {
        return Ipv4Addr::new(10, 0, 0, 1);
    } else if ip == Ipv4Addr::new(1, 1, 1, 1) && is_source {
        return Ipv4Addr::new(8, 8, 8, 8);
    } else if ip == Ipv4Addr::new(8, 8, 8, 8) && !is_source {
        return Ipv4Addr::new(1, 1, 1, 1);
    } else {
        return ip;
    }
}

/// Parse a packet and print some information about it.
/// Returns false if the packet should be dropped.
pub fn parse_packet(buf: &[u8]) -> (bool, Option<Vec<u8>>) {
    match SlicedPacket::from_ip(buf) {
        Err(value) => println!("Err {:?}", value),
        Ok(value) => {
            let packet_len;
            let builder;
            match value.ip.unwrap() {
                Ipv4(header, _extension) => {
                    print!("IPv4 src: {:?} ", header.source_addr().to_string());
                    print!("IPv4 dst: {:?} ", header.destination_addr().to_string());
                    packet_len = header.payload_len() as usize;
                    builder = PacketBuilder::ipv4(
                        rewrite_ip(header.source_addr(), true).octets(),
                        rewrite_ip(header.destination_addr(), false).octets(),
                        64,
                    );
                }
                Ipv6(header, _extension) => {
                    print!("IPv6 src: {:?} ", header.source_addr().to_string());
                    print!("IPv6 dst: {:?} ", header.destination_addr().to_string());
                    packet_len = header.payload_length() as usize;
                    builder = PacketBuilder::ipv6(
                        header.source_addr().octets(),
                        header.destination_addr().octets(),
                        64,
                    );
                }
            }

            match value.transport.unwrap() {
                Icmpv4(data) => {
                    print!("ICMPv4: {:?} ", data.icmp_type());
                    let builder = builder.icmpv4(data.icmp_type());
                    let mut result = Vec::<u8>::with_capacity(builder.size(data.payload().len()));
                    builder.write(&mut result, data.payload()).unwrap();
                    return (true, Some(result));
                }
                Icmpv6(data) => {
                    print!("ICMPv6: {:?} ", data.icmp_type());
                    // Not implemented currently
                }
                Tcp(data) => {
                    print!(
                        "TCP: port src {:?} dst {:?} seq {:?} ",
                        data.source_port(),
                        data.destination_port(),
                        data.sequence_number()
                    );
                    let mut builder = builder
                        .tcp(
                            data.source_port(),
                            data.destination_port(),
                            data.sequence_number(),
                            data.window_size(),
                        )
                        .options_raw(data.options())
                        .unwrap();
                    if data.ack() {
                        print!("ACK ");
                        builder = builder.ack(data.acknowledgment_number());
                    }
                    if data.syn() {
                        print!("SYN ");
                        builder = builder.syn();
                    }
                    if data.fin() {
                        print!("FIN ");
                        builder = builder.fin();
                    }
                    if data.psh() {
                        print!("PSH ");
                        builder = builder.psh();
                    }
                    if data.rst() {
                        print!("RST ");
                        builder = builder.rst();
                    }
                    if data.urg() {
                        print!("URG ");
                        builder = builder.urg(data.urgent_pointer());
                    }
                    if data.ns() {
                        print!("NS ");
                        builder = builder.ns();
                    }
                    if data.cwr() {
                        print!("CWR ");
                        builder = builder.cwr();
                    }
                    if data.ece() {
                        print!("ECE ");
                        builder = builder.ece();
                    }

                    let payload_length = packet_len - 4 * (data.data_offset() as usize);
                    println!("payload length: {:?} ", payload_length);
                    let payload = &value.payload[..payload_length].to_vec();
                    //println!("payload: {:?}", payload);
                    let payload_string = String::from_utf8_lossy(payload);
                    println!("payload string: {:?}", payload_string);
                    let mut result = Vec::<u8>::with_capacity(builder.size(payload.len()));
                    builder.write(&mut result, &payload).unwrap();
                    return (true, Some(result));
                }
                Udp(data) => {
                    print!(
                        "UDP: port src {:?} dst {:?} size {:?} ",
                        data.source_port(),
                        data.destination_port(),
                        data.length(),
                    );
                    let payload_length = data.length() as usize;
                    let payload_slice = &value.payload[0..payload_length];
                    let builder = builder.udp(data.source_port(), data.destination_port());
                    let mut result = Vec::<u8>::with_capacity(builder.size(payload_length));
                    builder.write(&mut result, payload_slice).unwrap();
                    return (true, Some(result));
                }
                Unknown(_data) => {
                    print!("Unknown ");
                }
            }
        }
    }
    return (false, None);
}
