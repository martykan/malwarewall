use std::net::Ipv4Addr;

#[derive(Clone, Copy, Debug)]
pub struct RouteEntry {
    pub ip: Ipv4Addr,
    pub mac: [u8; 6],
    pub rewrite_ip: Ipv4Addr,
}

#[derive(Clone, Debug)]
pub struct RoutesCache {
    routes: Vec<RouteEntry>,
}

impl RoutesCache {
    pub fn new() -> RoutesCache {
        RoutesCache { routes: Vec::new() }
    }

    pub fn get_route(&self, ip: Ipv4Addr) -> Option<RouteEntry> {
        for route in self.routes.iter() {
            if route.ip == ip || route.rewrite_ip == ip {
                return Some(route.clone());
            }
        }
        return None;
    }

    pub fn get_route_by_mac(&self, mac: [u8; 6]) -> Option<RouteEntry> {
        for route in self.routes.iter() {
            if route.mac == mac {
                return Some(route.clone());
            }
        }
        return None;
    }

    pub fn add_route(&mut self, ip: Ipv4Addr, mac: [u8; 6]) -> RouteEntry {
        if let Some(route) = self.get_route(ip) {
            return route;
        }
        println!("Adding route for {} with MAC {:02x?}", ip, mac);
        if let Some(route) = self.get_route_by_mac(mac) {
            println!(
                "Route for {} already exists with MAC {:02x?} / {:02x?}",
                ip, mac, route.mac
            );
            let entry = RouteEntry {
                ip,
                mac,
                rewrite_ip: route.rewrite_ip,
            };
            self.routes.push(entry.clone());
            return entry;
        } else {
            let rewrite_ip =
                Ipv4Addr::new(10, 2, 0, std::cmp::min(self.routes.len() as u8 + 2, 244));
            let entry = RouteEntry {
                ip,
                mac,
                rewrite_ip,
            };
            self.routes.push(entry.clone());
            return entry;
        }
    }
}
