use std::sync::Mutex;

use crate::config::Config;
use crate::data::flow_cache::FlowCache;
use crate::data::routes::RoutesCache;
use crate::handlers::ip_list_filter::ListFilter;
use crate::handlers::ip_redirect::IpRedirectFilter;
use crate::handlers::rate_limit::RateLimit;
use crate::handlers::FilterModule;
use std::sync::Arc;

/// Context is a struct that contains all the data that is shared between the different modules.
#[derive(Debug)]
pub struct AppContext {
    pub config: Config,
    pub routes: RoutesCache,
    pub flow_cache: FlowCache,
    pub filters: Vec<FilterModule>,
}

pub type AppContextRef = Arc<Mutex<AppContext>>;

impl AppContext {
    pub fn new(config: Config) -> AppContextRef {
        let ctx = Arc::new(Mutex::new(AppContext {
            config: config,
            routes: RoutesCache::new(),
            flow_cache: FlowCache::new(),
            filters: vec![],
        }));
        // Load the filter modules
        {
            let mut ctx_mut = ctx.lock().unwrap();
            ctx_mut.filters.push(ListFilter::new_module(ctx.clone()));
            ctx_mut
                .filters
                .push(IpRedirectFilter::new_module(ctx.clone()));
            ctx_mut.filters.push(RateLimit::new_module(ctx.clone()));
        }
        return ctx;
    }
}
