use std::net::Ipv4Addr;

use regex::Regex;

use crate::context::AppContextRef;
use crate::data::flow_cache::FlowProtocol;

use super::CommonFilterModule;
use super::FilterModule;
use super::IpFilterModule;
use super::IpFilterRequest;
use super::IpFilterResponse;

pub struct DnsFilter {
    ctx: AppContextRef,
}

impl DnsFilter {
    pub fn new(ctx: AppContextRef) -> Box<DnsFilter> {
        return Box::new(DnsFilter { ctx: ctx });
    }

    pub fn new_module(ctx: AppContextRef) -> FilterModule {
        return FilterModule::Ip(DnsFilter::new(ctx));
    }

    /**
     * Returns true if the packet should be dropped
     */
    fn handle_dns_packet(&self, payload_slice: &[u8]) -> bool {
        let mut whitelist_regex: Vec<Regex> = vec![];
        let mut blacklist_regex: Vec<Regex> = vec![];
        {
            self.ctx
                .config
                .read()
                .unwrap()
                .filters
                .dns
                .iter()
                .for_each(|x| {
                    if x.allow {
                        whitelist_regex.push(Regex::new(&x.regex).unwrap());
                    } else {
                        blacklist_regex.push(Regex::new(&x.regex).unwrap());
                    }
                });
        }
        let dns_packet = dns_parser::Packet::parse(payload_slice).unwrap();
        for question in dns_packet.questions {
            for regex in &whitelist_regex {
                if regex.is_match(&question.qname.to_string()) {
                    warn!("DNS whitelisted {}", &question.qname.to_string());
                    return false;
                }
            }
            for regex in &blacklist_regex {
                if regex.is_match(&question.qname.to_string()) {
                    warn!("DNS blacklisted {}", &question.qname.to_string());
                    return true;
                }
            }
        }
        return false;
    }
}

impl CommonFilterModule for DnsFilter {}

impl IpFilterModule for DnsFilter {
    fn ip_filter(&self, request: &IpFilterRequest) -> IpFilterResponse {
        if request.protocol == FlowProtocol::UDP && request.dst_port == 53 {
            let drop = self.handle_dns_packet(request.payload.as_slice());
            if drop {
                return IpFilterResponse {
                    new_dst_ip: Some(Ipv4Addr::UNSPECIFIED),
                    end: true,
                    ..Default::default()
                };
            }
        }
        return IpFilterResponse::default();
    }
}
