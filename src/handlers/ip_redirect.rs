use std::net::Ipv4Addr;

use cidr::Ipv4Inet;

use crate::config::Redirect;
use crate::context::AppContextRef;

use super::CommonFilterModule;
use super::FilterModule;
use super::IpFilterModule;
use super::IpFilterRequest;
use super::IpFilterResponse;

pub struct IpRedirectFilter {
    ctx: AppContextRef,
}

impl IpRedirectFilter {
    pub fn new(ctx: AppContextRef) -> Box<IpRedirectFilter> {
        return Box::new(IpRedirectFilter { ctx: ctx });
    }

    pub fn new_module(ctx: AppContextRef) -> FilterModule {
        return FilterModule::Ip(IpRedirectFilter::new(ctx));
    }

    fn ip_filter_single_ip(&self, ip: &Ipv4Addr, port: u16) -> (Option<Ipv4Addr>, Option<u16>) {
        let config = &mut self.ctx.config.write().unwrap();
        let mut new_ip = None;
        let mut new_port = None;
        let mut save_permanent = false;
        for redirect in config.filters.redirect.iter() {
            if redirect.from_ip.contains(ip) {
                // Check if the port matches
                if redirect.from_port.is_some() && redirect.from_port.unwrap() != port {
                    continue;
                }
                // If there is a chance, check if we should redirect
                if redirect.chance < 1.0 {
                    let random = rand::random::<f32>();
                    if random > redirect.chance {
                        continue;
                    }
                    // Chance passed, need to make it permanent
                    save_permanent = true;
                }

                new_ip = Some(redirect.to_ip);
                new_port = redirect.to_port;
                println!("Redirecting IP: {:?} to {:?}", ip, new_ip);
                break;
            }
        }
        if save_permanent {
            config.filters.redirect.insert(
                0,
                Redirect {
                    from_ip: Ipv4Inet::new(ip.clone(), 32).unwrap(),
                    from_port: Some(port),
                    to_ip: new_ip.unwrap(),
                    to_port: new_port,
                    chance: 1.0,
                },
            );
        }
        return (new_ip, new_port);
    }
}

impl CommonFilterModule for IpRedirectFilter {}

impl IpFilterModule for IpRedirectFilter {
    fn ip_filter(&self, request: &IpFilterRequest) -> IpFilterResponse {
        let (new_src_ip, new_src_port) =
            self.ip_filter_single_ip(&request.src_ip, request.src_port);
        let (new_dst_ip, new_dst_port) =
            self.ip_filter_single_ip(&request.dst_ip, request.dst_port);
        if new_dst_ip.is_some() || new_dst_port.is_some() {
            // Add a back redirect
            let back_from_ip = if new_dst_ip.is_some() {
                new_dst_ip.unwrap()
            } else {
                request.dst_ip.clone()
            };
            let back_from_port = if new_dst_port.is_some() {
                new_dst_port
            } else {
                Some(request.dst_port)
            };
            let back_to_port = if new_dst_port.is_some() {
                Some(request.dst_port)
            } else {
                None
            };
            let config = &mut self.ctx.config.write().unwrap();
            let redirect = Redirect {
                from_ip: Ipv4Inet::new(back_from_ip, 32).unwrap(),
                to_ip: request.dst_ip.clone(),
                from_port: back_from_port,
                to_port: back_to_port,
                ..Default::default()
            };
            let already_exists = config
                .filters
                .redirect
                .iter()
                .any(|r| r.from_ip == redirect.from_ip && r.from_port == redirect.from_port);
            if !already_exists {
                println!("Adding back redirect");
                config.filters.redirect.push(redirect);
            }
        }
        return IpFilterResponse {
            new_src_ip,
            new_dst_ip,
            new_src_port,
            new_dst_port,
            end: new_dst_port.is_some()
                || new_dst_ip.is_some()
                || new_src_port.is_some()
                || new_src_ip.is_some(),
        };
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        config::{Config, Filters, Redirect},
        context::AppContext,
    };

    use super::*;
    use std::net::Ipv4Addr;

    #[test]
    fn test_ip_filter_no_redirect() {
        let ctx = AppContext::new(Config::default());
        let module = IpRedirectFilter::new(ctx);

        let req = IpFilterRequest {
            src_ip: Ipv4Addr::new(10, 1, 0, 1),
            dst_ip: Ipv4Addr::new(192, 168, 0, 1),
            src_port: 1234,
            dst_port: 80,
        };
        let res = module.ip_filter(&req);
        assert_eq!(res.new_dst_ip, None);

        let req = IpFilterRequest {
            src_ip: Ipv4Addr::new(192, 168, 0, 1),
            dst_ip: Ipv4Addr::new(10, 1, 0, 1),
            src_port: 80,
            dst_port: 1234,
        };
        let res = module.ip_filter(&req);
        assert_eq!(res.new_dst_ip, None);
    }

    #[test]
    fn test_ip_filter_redirect() {
        let config = Config {
            filters: Filters {
                redirect: vec![Redirect {
                    from_ip: Ipv4Inet::new(Ipv4Addr::new(192, 168, 0, 1), 32).unwrap(),
                    to_ip: Ipv4Addr::new(10, 0, 0, 1),
                    from_port: Some(80),
                    to_port: Some(8080),
                    chance: 1.0,
                    ..Default::default()
                }],
                ..Default::default()
            },
        };
        let ctx = AppContext::new(config);
        let module = IpRedirectFilter::new(ctx);

        let req = IpFilterRequest {
            src_ip: Ipv4Addr::new(10, 1, 0, 1),
            dst_ip: Ipv4Addr::new(192, 168, 0, 1),
            src_port: 1234,
            dst_port: 80,
        };
        let res = module.ip_filter(&req);
        assert_eq!(res.new_dst_ip, Some(Ipv4Addr::new(10, 0, 0, 1)));
        assert_eq!(res.new_dst_port, Some(8080));

        let req = IpFilterRequest {
            src_ip: Ipv4Addr::new(10, 0, 0, 1),
            dst_ip: Ipv4Addr::new(10, 1, 0, 1),
            src_port: 8080,
            dst_port: 1234,
        };
        let res = module.ip_filter(&req);
        assert_eq!(res.new_src_ip, Some(Ipv4Addr::new(192, 168, 0, 1)));
        assert_eq!(res.new_src_port, Some(80));
    }

    #[test]
    fn test_ip_filter_redirect_ip_only() {
        let config = Config {
            filters: Filters {
                redirect: vec![Redirect {
                    from_ip: Ipv4Inet::new(Ipv4Addr::new(192, 168, 0, 1), 32).unwrap(),
                    to_ip: Ipv4Addr::new(10, 0, 0, 1),
                    ..Default::default()
                }],
                ..Default::default()
            },
        };
        let ctx = AppContext::new(config);
        let module = IpRedirectFilter::new(ctx.clone());

        let req = IpFilterRequest {
            src_ip: Ipv4Addr::new(10, 1, 0, 1),
            dst_ip: Ipv4Addr::new(192, 168, 0, 1),
            src_port: 1234,
            dst_port: 80,
        };
        let res = module.ip_filter(&req);
        assert_eq!(res.new_dst_ip, Some(Ipv4Addr::new(10, 0, 0, 1)));
        assert_eq!(res.new_dst_port, None);

        let req = IpFilterRequest {
            src_ip: Ipv4Addr::new(10, 0, 0, 1),
            dst_ip: Ipv4Addr::new(10, 1, 0, 1),
            src_port: 80,
            dst_port: 1234,
        };
        let res = module.ip_filter(&req);
        assert_eq!(res.new_src_ip, Some(Ipv4Addr::new(192, 168, 0, 1)));
        assert_eq!(res.new_src_port, None);

        // Has new rule, but only 2
        {
            assert_eq!(ctx.clone().config.read().unwrap().filters.redirect.len(), 2);
        }
    }

    #[test]
    pub fn test_ip_filter_chance() {
        let config = Config {
            filters: Filters {
                redirect: vec![Redirect {
                    from_ip: Ipv4Inet::new(Ipv4Addr::new(192, 168, 0, 1), 32).unwrap(),
                    to_ip: Ipv4Addr::new(10, 0, 0, 1),
                    chance: 0.999999, // Test may fail sometimes lol
                    ..Default::default()
                }],
                ..Default::default()
            },
        };
        let ctx = AppContext::new(config);
        let module = IpRedirectFilter::new(ctx.clone());

        let req = IpFilterRequest {
            src_ip: Ipv4Addr::new(10, 1, 0, 1),
            dst_ip: Ipv4Addr::new(192, 168, 0, 1),
            src_port: 1234,
            dst_port: 80,
        };
        let res = module.ip_filter(&req);
        assert_eq!(res.new_dst_ip, Some(Ipv4Addr::new(10, 0, 0, 1)));
        assert_eq!(res.new_dst_port, None);

        let req = IpFilterRequest {
            src_ip: Ipv4Addr::new(10, 0, 0, 1),
            dst_ip: Ipv4Addr::new(10, 1, 0, 1),
            src_port: 80,
            dst_port: 1234,
        };
        let res = module.ip_filter(&req);
        assert_eq!(res.new_src_ip, Some(Ipv4Addr::new(192, 168, 0, 1)));
        assert_eq!(res.new_src_port, None);

        // Has new rule
        {
            assert_eq!(ctx.clone().config.read().unwrap().filters.redirect.len(), 3);
            assert_eq!(
                ctx.clone().config.read().unwrap().filters.redirect[0],
                Redirect {
                    from_ip: Ipv4Inet::new(Ipv4Addr::new(192, 168, 0, 1), 32).unwrap(),
                    from_port: Some(80),
                    to_ip: Ipv4Addr::new(10, 0, 0, 1),
                    chance: 1.0,
                    ..Default::default()
                }
            );
        }
    }
}
