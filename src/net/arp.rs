use etherparse::Ethernet2Header;
use etherparse::SlicedPacket;

use crate::constants::MY_MAC;
use crate::types::OutputMode;

pub fn handle_arp(buf: &[u8]) -> (OutputMode, Option<Vec<u8>>) {
    let packet = SlicedPacket::from_ethernet(buf).unwrap();
    let arp = packet.payload;

    // Parse the ARP header
    // (Interface tap10 is asking for the MAC address of a host on the outside world)
    let header_eth_ipv4 = [00, 01, 08, 00, 06, 04, 00, 01];
    if arp[0..8] != header_eth_ipv4 {
        println!("Unsupported ARP header (not ethernet/IPv4 request)");
        return (OutputMode::DROP, None);
    }
    let sha = [arp[8], arp[9], arp[10], arp[11], arp[12], arp[13]];
    let spa = [arp[14], arp[15], arp[16], arp[17]];
    let tha = [arp[18], arp[19], arp[20], arp[21], arp[22], arp[23]];
    let tpa = [arp[24], arp[25], arp[26], arp[27]];
    println!("SHA: {:02x?}", sha);
    println!("SPA: {:?}", spa);
    println!("THA: {:02x?}", tha);
    println!("TPA: {:0?}", tpa);
    if spa == tpa {
        println!("ARP request for self, ignoring");
        return (OutputMode::DROP, None);
    }
    let mut new_sha = MY_MAC;
    if sha != MY_MAC {
        new_sha[5] = sha[5];
    }
    let output_eth = Ethernet2Header {
        destination: sha,
        source: new_sha,
        ether_type: 0x0806,
    };
    let output_arp = [
        0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x02, // Header
        new_sha[0], new_sha[1], new_sha[2], new_sha[3], new_sha[4], new_sha[5], // SHA
        tpa[0], tpa[1], tpa[2], tpa[3], // TPA
        tha[0], tha[1], tha[2], tha[3], tha[4], tha[5], // THA
        spa[0], spa[1], spa[2], spa[3], // SPA
    ];
    let mut output = Vec::new();
    output.extend_from_slice(&output_eth.to_bytes());
    output.extend_from_slice(&output_arp);
    return (OutputMode::REPLY, Some(output));
}
