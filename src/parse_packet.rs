use etherparse::Ethernet2Header;
use etherparse::InternetSlice::*;
use etherparse::LinkSlice::*;
use etherparse::PacketBuilder;
use etherparse::PacketBuilderStep;
use etherparse::SlicedPacket;
use etherparse::TransportSlice::*;
use lazy_static::lazy_static;
use std::net::Ipv4Addr;
use std::sync::Mutex;

mod routes;
use routes::RoutesCache;
mod flow_cache;
use flow_cache::FlowCache;
use flow_cache::FlowProtocol;
mod arp;
use arp::handle_arp;

use crate::init::MY_MAC;

lazy_static! {
    static ref ROUTES: Mutex<RoutesCache> = Mutex::new(RoutesCache::new());
    static ref FLOW_CACHE: Mutex<FlowCache> = Mutex::new(FlowCache::new());
}

#[derive(PartialEq, Eq)]
pub enum OutputMode {
    DROP,
    FORWARD,
    REPLY,
}

/// Rewrite the IP address based on preset rules.
fn rewrite_ip(ip: Ipv4Addr, is_source: bool) -> Ipv4Addr {
    // Custom rewrite rules
    if ip == Ipv4Addr::new(1, 1, 1, 1) && is_source {
        return Ipv4Addr::new(8, 8, 8, 8);
    } else if ip == Ipv4Addr::new(8, 8, 8, 8) && !is_source {
        return Ipv4Addr::new(1, 1, 1, 1);
    } else if ip == Ipv4Addr::new(172, 17, 0, 2) && is_source {
        return Ipv4Addr::new(194, 50, 64, 66);
    } else if ip == Ipv4Addr::new(194, 50, 64, 66) && !is_source {
        return Ipv4Addr::new(172, 17, 0, 2);
    }

    // Rewrite rules based on routes
    if let Some(route) = ROUTES.lock().unwrap().get_route(ip) {
        if is_source {
            return route.rewrite_ip;
        } else {
            return route.ip;
        }
    }

    return ip;
}

fn parse_packet_l3(
    outbound: bool,
    value: SlicedPacket,
    eth_builder: Option<PacketBuilderStep<Ethernet2Header>>,
) -> (OutputMode, Option<Vec<u8>>) {
    let packet_len;
    let builder;
    let flow_src_ip;
    let flow_dst_ip;
    let middlebox_ip;
    match value.ip.unwrap() {
        Ipv4(header, _extension) => {
            print!("IPv4 src: {:?} ", header.source_addr().to_string());
            print!("IPv4 dst: {:?} ", header.destination_addr().to_string());
            packet_len = header.payload_len() as usize;
            let src_ip = rewrite_ip(header.source_addr(), true).octets();
            let dst_ip = rewrite_ip(header.destination_addr(), false).octets();
            match eth_builder {
                Some(eth_builder) => {
                    // Inbound packet
                    builder = eth_builder.ipv4(src_ip, dst_ip, 64);
                    flow_src_ip = Ipv4Addr::from(dst_ip);
                    flow_dst_ip = Ipv4Addr::from(src_ip);
                    middlebox_ip = header.destination_addr();
                }
                None => {
                    // Outbound packet
                    builder = PacketBuilder::ipv4(src_ip, dst_ip, 64);
                    flow_src_ip = header.source_addr();
                    flow_dst_ip = header.destination_addr();
                    middlebox_ip = Ipv4Addr::from(src_ip);
                }
            }
        }
        Ipv6(header, _extension) => {
            print!("IPv6 src: {:?} ", header.source_addr().to_string());
            print!("IPv6 dst: {:?} ", header.destination_addr().to_string());
            // IPv6 not implemented currently
            return (OutputMode::DROP, None);
        }
    }

    match value.transport.unwrap() {
        Icmpv4(data) => {
            print!("ICMPv4: {:?} ", data.icmp_type());
            let builder = builder.icmpv4(data.icmp_type());
            let mut result = Vec::<u8>::with_capacity(builder.size(data.payload().len()));
            builder.write(&mut result, data.payload()).unwrap();
            FLOW_CACHE.lock().unwrap().log_packet(
                outbound,
                flow_src_ip,
                flow_dst_ip,
                middlebox_ip,
                FlowProtocol::ICMP,
                0,
                0,
                0,
            );
            return (OutputMode::FORWARD, Some(result));
        }
        Icmpv6(data) => {
            print!("ICMPv6: {:?} ", data.icmp_type());
            // Not implemented currently
        }
        Tcp(data) => {
            print!(
                "TCP: port src {:?} dst {:?} seq {:?} ",
                data.source_port(),
                data.destination_port(),
                data.sequence_number()
            );
            let mut builder = builder
                .tcp(
                    data.source_port(),
                    data.destination_port(),
                    data.sequence_number(),
                    data.window_size(),
                )
                .options_raw(data.options())
                .unwrap();
            if data.ack() {
                print!("ACK ");
                builder = builder.ack(data.acknowledgment_number());
            }
            if data.syn() {
                print!("SYN ");
                builder = builder.syn();
            }
            if data.fin() {
                print!("FIN ");
                builder = builder.fin();
            }
            if data.psh() {
                print!("PSH ");
                builder = builder.psh();
            }
            if data.rst() {
                print!("RST ");
                builder = builder.rst();
            }
            if data.urg() {
                print!("URG ");
                builder = builder.urg(data.urgent_pointer());
            }
            if data.ns() {
                print!("NS ");
                builder = builder.ns();
            }
            if data.cwr() {
                print!("CWR ");
                builder = builder.cwr();
            }
            if data.ece() {
                print!("ECE ");
                builder = builder.ece();
            }

            let payload_length = packet_len - 4 * (data.data_offset() as usize);
            println!("payload length: {:?} ", payload_length);
            let payload = &value.payload[..payload_length].to_vec();
            let payload_string = String::from_utf8_lossy(payload);
            println!("payload string: {:?}", payload_string);
            let mut result = Vec::<u8>::with_capacity(builder.size(payload.len()));
            builder.write(&mut result, &payload).unwrap();
            FLOW_CACHE.lock().unwrap().log_packet(
                outbound,
                flow_src_ip,
                flow_dst_ip,
                middlebox_ip,
                FlowProtocol::TCP,
                if outbound {
                    data.source_port()
                } else {
                    data.destination_port()
                },
                if outbound {
                    data.destination_port()
                } else {
                    data.source_port()
                },
                payload_length,
            );
            return (OutputMode::FORWARD, Some(result));
        }
        Udp(data) => {
            print!(
                "UDP: port src {:?} dst {:?} size {:?} ",
                data.source_port(),
                data.destination_port(),
                data.length(),
            );
            let payload_length = data.length() as usize;
            println!("payload length: {:?} ", payload_length);
            let payload_slice = &value.payload[0..payload_length];
            let builder = builder.udp(data.source_port(), data.destination_port());
            let mut result = Vec::<u8>::with_capacity(builder.size(payload_length));
            builder.write(&mut result, payload_slice).unwrap();
            FLOW_CACHE.lock().unwrap().log_packet(
                outbound,
                flow_src_ip,
                flow_dst_ip,
                middlebox_ip,
                FlowProtocol::UDP,
                if outbound {
                    data.source_port()
                } else {
                    data.destination_port()
                },
                if outbound {
                    data.destination_port()
                } else {
                    data.source_port()
                },
                payload_length,
            );
            return (OutputMode::FORWARD, Some(result));
        }
        Unknown(_data) => {
            print!("Unknown ");
        }
    }
    return (OutputMode::DROP, None);
}

/// Parse a packet and print some information about it.
/// Returns false if the packet should be dropped. Otherwise returns true and the modified packet content.
pub fn parse_packet(outbound: bool, buf: &[u8]) -> (OutputMode, Option<Vec<u8>>) {
    if outbound {
        match SlicedPacket::from_ethernet(buf) {
            Err(value) => println!("Err {:?}", value),
            Ok(value) => match value.link.as_ref().unwrap() {
                Ethernet2(ethernet) => {
                    println!(
                        "Ethernet2: {:02x?} -> {:02x?}, type: {:04x?}",
                        ethernet.source(),
                        ethernet.destination(),
                        ethernet.ether_type()
                    );
                    if ethernet.ether_type() == 0x0806 {
                        return handle_arp(buf);
                    }
                    match value.ip.as_ref() {
                        Some(Ipv4(header, _extension)) => {
                            ROUTES
                                .lock()
                                .unwrap()
                                .add_route(header.source_addr(), ethernet.source());
                            return parse_packet_l3(outbound, value, None);
                        }
                        _ => {
                            println!("Unsupported network layer");
                            return (OutputMode::DROP, None);
                        }
                    }
                }
            },
        }
    } else {
        match SlicedPacket::from_ip(buf) {
            Err(value) => println!("Err {:?}", value),
            Ok(value) => match value.ip.as_ref() {
                // Find the route entry by the destination IP
                Some(Ipv4(header, _extension)) => {
                    let route = ROUTES.lock().unwrap().get_route(header.destination_addr());
                    match route {
                        Some(route) => {
                            let eth_builder = PacketBuilder::ethernet2(MY_MAC, route.mac);
                            return parse_packet_l3(outbound, value, Some(eth_builder));
                        }
                        None => {
                            println!("No route found");
                            return (OutputMode::DROP, None);
                        }
                    }
                }
                _ => {
                    println!("Unsupported network layer");
                    return (OutputMode::DROP, None);
                }
            },
        }
    }
    return (OutputMode::DROP, None);
}
