use std::{
    collections::{hash_map::DefaultHasher, HashMap},
    hash::Hash,
    hash::Hasher,
    net::Ipv4Addr,
    time::SystemTime,
};

#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub enum FlowProtocol {
    TCP,
    UDP,
    ICMP,
}

#[derive(Clone, Copy, Debug)]
pub struct FlowEntry {
    pub flow_id: u64,
    pub src_ip: Ipv4Addr,
    pub dst_ip: Ipv4Addr,
    pub middlebox_ip: Ipv4Addr,
    pub protocol: FlowProtocol,
    pub src_port: u16,
    pub dst_port: u16,
    pub timestamp_started: SystemTime,
    pub timestamp_last: SystemTime,
    pub packets_in: u64,
    pub bytes_in: u64,
    pub packets_out: u64,
    pub bytes_out: u64,
}

impl FlowEntry {
    pub fn generate_id(
        src_ip: Ipv4Addr,
        dst_ip: Ipv4Addr,
        protocol: FlowProtocol,
        src_port: u16,
        dst_port: u16,
    ) -> u64 {
        let mut hasher = DefaultHasher::new();
        src_ip.hash(&mut hasher);
        dst_ip.hash(&mut hasher);
        protocol.hash(&mut hasher);
        src_port.hash(&mut hasher);
        dst_port.hash(&mut hasher);
        hasher.finish()
    }

    pub fn new(
        flow_id: u64,
        src_ip: Ipv4Addr,
        dst_ip: Ipv4Addr,
        middlebox_ip: Ipv4Addr,
        protocol: FlowProtocol,
        src_port: u16,
        dst_port: u16,
    ) -> FlowEntry {
        let timestamp = SystemTime::now();
        FlowEntry {
            flow_id: flow_id,
            src_ip: src_ip,
            dst_ip: dst_ip,
            middlebox_ip: middlebox_ip,
            protocol: protocol,
            src_port: src_port,
            dst_port: dst_port,
            timestamp_started: timestamp,
            timestamp_last: timestamp,
            packets_in: 0,
            bytes_in: 0,
            packets_out: 0,
            bytes_out: 0,
        }
    }

    pub fn update(&mut self, outbound: bool, len: usize) {
        self.timestamp_last = SystemTime::now();
        if outbound {
            self.packets_out += 1;
            self.bytes_out += len as u64;
        } else {
            self.packets_in += 1;
            self.bytes_in += len as u64;
        }
    }
}

#[derive(Debug)]
pub struct FlowCache {
    pub flows: HashMap<u64, FlowEntry>,
}

impl FlowCache {
    pub fn new() -> FlowCache {
        FlowCache {
            flows: HashMap::new(),
        }
    }

    pub fn add_flow(&mut self, flow: FlowEntry) {
        self.flows.insert(flow.flow_id, flow);
    }

    pub fn get_flow(&self, flow_id: u64) -> Option<&FlowEntry> {
        self.flows.get(&flow_id)
    }

    pub fn get_flow_mut(&mut self, flow_id: u64) -> Option<&mut FlowEntry> {
        self.flows.get_mut(&flow_id)
    }

    pub fn log_packet(
        &mut self,
        outbound: bool,
        src_ip: Ipv4Addr,
        dst_ip: Ipv4Addr,
        middlebox_ip: Ipv4Addr,
        protocol: FlowProtocol,
        src_port: u16,
        dst_port: u16,
        len: usize,
    ) {
        let flow_id = FlowEntry::generate_id(src_ip, dst_ip, protocol, src_port, dst_port);
        if let Some(flow) = self.get_flow_mut(flow_id) {
            flow.update(outbound, len);
        } else {
            let mut flow = FlowEntry::new(
                flow_id,
                src_ip,
                dst_ip,
                middlebox_ip,
                protocol,
                src_port,
                dst_port,
            );
            flow.update(outbound, len);
            self.add_flow(flow);
        }
        self.print_flows();
    }

    pub fn print_flows(&self) {
        for (_, flow) in self.flows.iter() {
            println!(
                "\nFlow: {} {}:{} -> ({}) -> {}:{}",
                flow.flow_id,
                flow.src_ip,
                flow.src_port,
                flow.middlebox_ip,
                flow.dst_ip,
                flow.dst_port
            );
            println!(
                "  Started: {}",
                flow.timestamp_started
                    .duration_since(SystemTime::UNIX_EPOCH)
                    .unwrap()
                    .as_secs()
            );
            println!(
                "  Last: {}",
                flow.timestamp_last
                    .duration_since(SystemTime::UNIX_EPOCH)
                    .unwrap()
                    .as_secs()
            );
            println!("  Packets In: {}", flow.packets_in);
            println!("  Bytes In: {}", flow.bytes_in);
            println!("  Packets Out: {}", flow.packets_out);
            println!("  Bytes Out: {}", flow.bytes_out);
        }
    }

    pub fn iter(&self) -> std::collections::hash_map::Iter<u64, FlowEntry> {
        self.flows.iter()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_flow_cache() {
        let mut flow_cache = FlowCache::new();
        let flow_id = FlowEntry::generate_id(
            Ipv4Addr::new(192, 168, 1, 1),
            Ipv4Addr::new(192, 168, 1, 2),
            FlowProtocol::TCP,
            1234,
            80,
        );
        let flow = FlowEntry::new(
            flow_id,
            Ipv4Addr::new(192, 168, 1, 1),
            Ipv4Addr::new(192, 168, 1, 2),
            Ipv4Addr::new(192, 168, 1, 3),
            FlowProtocol::TCP,
            1234,
            80,
        );
        flow_cache.add_flow(flow);
        let flow = flow_cache.get_flow(flow_id).unwrap();
        assert_eq!(flow.src_ip, Ipv4Addr::new(192, 168, 1, 1));
        assert_eq!(flow.dst_ip, Ipv4Addr::new(192, 168, 1, 2));
        assert_eq!(flow.middlebox_ip, Ipv4Addr::new(192, 168, 1, 3));
        assert_eq!(flow.protocol, FlowProtocol::TCP);
        assert_eq!(flow.src_port, 1234);
        assert_eq!(flow.dst_port, 80);
        assert_eq!(flow.packets_in, 0);
        assert_eq!(flow.bytes_in, 0);
        assert_eq!(flow.packets_out, 0);
        assert_eq!(flow.bytes_out, 0);
        let flow = flow_cache.get_flow_mut(flow_id).unwrap();
        flow.update(true, 100);
        assert_eq!(flow.packets_in, 0);
        assert_eq!(flow.bytes_in, 0);
        assert_eq!(flow.packets_out, 1);
        assert_eq!(flow.bytes_out, 100);
        flow.update(false, 200);
        assert_eq!(flow.packets_in, 1);
        assert_eq!(flow.bytes_in, 200);
        assert_eq!(flow.packets_out, 1);
        assert_eq!(flow.bytes_out, 100);
    }
}
