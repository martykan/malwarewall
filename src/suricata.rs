use async_std::{
    fs::File,
    io::{prelude::SeekExt, ReadExt},
    task::{self, JoinHandle},
};
use async_tun::result::Result;
use cidr::Ipv4Inet;
use std::{io::SeekFrom, net::Ipv4Addr, time::Duration};

use crate::{config::Filter, context::AppContextRef};

pub async fn suricata_monitor_process(ctx: AppContextRef) -> Result<()> {
    let filepath;
    {
        let conf = &ctx.config.read().unwrap();
        let suricata_conf = &conf.filters.suricata;
        if suricata_conf.is_none() {
            return Ok(());
        }
        let suricata_conf = suricata_conf.as_ref().unwrap();
        filepath = suricata_conf.log_path.clone();
    }
    let filepath_str = filepath.as_str();
    let mut file = File::open(filepath_str).await?;
    // Tail the file for new lines
    let mut filesize = file.metadata().await?.len();
    loop {
        file = File::open(filepath_str).await?;
        file.sync_all().await?;
        let new_filesize = file.metadata().await?.len();
        if new_filesize > filesize {
            file.seek(SeekFrom::Start(filesize)).await?;
            let mut buf = Vec::new();
            file.read_to_end(&mut buf).await?;
            let buf = String::from_utf8(buf)?;
            let lines = buf.split('\n');
            for line in lines {
                if line.is_empty() {
                    continue;
                }
                let line = line.trim();
                // Parse the line as JSON
                let json = serde_json::from_str(line);
                if json.is_err() {
                    warn!(
                        "Failed to parse suricata log line as JSON, {}",
                        json.err().unwrap()
                    );
                    continue;
                }
                let json: serde_json::Value = json.unwrap();
                let event_type = json["event_type"].as_str().unwrap();
                if event_type == "alert" {
                    let src_ip_str = json["src_ip"].as_str().unwrap();
                    let dest_ip_str = json["dest_ip"].as_str().unwrap();
                    let src_ip = src_ip_str.parse::<Ipv4Addr>().unwrap();
                    let dest_ip = dest_ip_str.parse::<Ipv4Addr>().unwrap();
                    let src_port = json["src_port"].as_u64().unwrap();
                    let dest_port = json["dest_port"].as_u64().unwrap();
                    let signature = json["alert"]["signature"].as_str().unwrap();
                    let severity = json["alert"]["severity"].as_u64().unwrap();
                    warn!("Suricata alert: {}, severity {}", signature, severity);
                    if severity <= 3 {
                        // High severity, block the IP
                        let target_ip;
                        let origin_ip;
                        let origin_port;
                        if src_ip.octets()[0] == 10 {
                            target_ip = dest_ip;
                            origin_ip = src_ip;
                            origin_port = src_port as u16;
                        } else {
                            target_ip = src_ip;
                            origin_ip = dest_ip;
                            origin_port = dest_port as u16;
                        }
                        warn!("Blocking {}:{}", origin_ip, origin_port);
                        warn!("Blocking {}", target_ip);
                        {
                            ctx.config.write().unwrap().filters.filterlist.push(Filter {
                                allow: false,
                                ip: Ipv4Inet::new(origin_ip, 32).unwrap(),
                                port: Some(origin_port as u16),
                            });
                            ctx.config.write().unwrap().filters.filterlist.push(Filter {
                                allow: false,
                                ip: Ipv4Inet::new(target_ip, 32).unwrap(),
                                port: None,
                            });
                        }
                    }
                }
            }
        }
        filesize = new_filesize;
        async_std::task::sleep(Duration::from_secs(1)).await;
    }
}

pub fn suricata_monitor(ctx: AppContextRef) -> JoinHandle<Result<()>> {
    return task::spawn(async move {
        loop {
            _ = suricata_monitor_process(ctx.clone()).await;

            async_std::task::sleep(Duration::from_secs(1)).await;
        }
    });
}
