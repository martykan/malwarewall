use std::net::Ipv4Addr;

use crate::config::Config;
use crate::context::AppContextRef;

use super::CommonFilterModule;
use super::FilterModule;
use super::IpFilterModule;
use super::IpFilterRequest;
use super::IpFilterResponse;

pub struct ListFilter {
    ctx: AppContextRef,
}

impl ListFilter {
    pub fn new(ctx: AppContextRef) -> Box<ListFilter> {
        return Box::new(ListFilter { ctx: ctx });
    }

    pub fn new_module(ctx: AppContextRef) -> FilterModule {
        return FilterModule::Ip(ListFilter::new(ctx));
    }
}

impl CommonFilterModule for ListFilter {}

impl IpFilterModule for ListFilter {
    fn ip_filter(&self, request: &IpFilterRequest) -> IpFilterResponse {
        let config = &self.ctx.config.read().unwrap();
        for filter in &config.filters.filterlist {
            if filter.ip.contains(&request.dst_ip)
                && (filter.port.is_none() || filter.port == Some(request.dst_port))
            {
                if filter.allow {
                    warn!("Whitelisted IP: {:?}", request.dst_ip);
                    break;
                } else {
                    warn!("Blacklisted IP: {:?}", request.dst_ip);
                    return IpFilterResponse {
                        new_dst_ip: Some(Ipv4Addr::UNSPECIFIED),
                        end: true,
                        ..Default::default()
                    };
                }
            }
        }
        return IpFilterResponse {
            new_dst_ip: None,
            end: false,
            ..Default::default()
        };
    }
}

mod tests {
    use super::*;

    use crate::{
        config::{Filter, Filters},
        context::AppContext,
    };
    use std::net::Ipv4Addr;

    #[test]
    fn test_ip_filter() {
        let config = Config {
            filters: Filters {
                filterlist: vec![
                    Filter {
                        allow: true,
                        ip: cidr::Ipv4Inet::new(Ipv4Addr::new(192, 168, 1, 100), 32).unwrap(),
                        port: None,
                    },
                    Filter {
                        allow: false,
                        ip: cidr::Ipv4Inet::new(Ipv4Addr::new(192, 168, 1, 1), 24).unwrap(),
                        port: None,
                    },
                    Filter {
                        allow: false,
                        ip: cidr::Ipv4Inet::new(Ipv4Addr::new(0, 0, 0, 0), 0).unwrap(),
                        port: Some(22),
                    },
                ],
                ..Default::default()
            },
        };
        let ctx = AppContext::new(config);

        let filter = ListFilter::new(ctx);

        // Should be blocked
        let request = IpFilterRequest {
            src_ip: Ipv4Addr::new(192, 168, 2, 1),
            dst_ip: Ipv4Addr::new(192, 168, 1, 1),
            src_port: 1234,
            dst_port: 80,
        };
        let response = filter.ip_filter(&request);
        assert_eq!(response.new_dst_ip, Some(Ipv4Addr::UNSPECIFIED));

        // Should pass through
        let request = IpFilterRequest {
            src_ip: Ipv4Addr::new(192, 168, 2, 1),
            dst_ip: Ipv4Addr::new(192, 168, 1, 100),
            src_port: 1234,
            dst_port: 80,
        };
        let response = filter.ip_filter(&request);
        assert_eq!(response.new_dst_ip, None);

        // Should pass through
        let request = IpFilterRequest {
            src_ip: Ipv4Addr::new(192, 168, 2, 1),
            dst_ip: Ipv4Addr::new(192, 168, 2, 101),
            src_port: 1234,
            dst_port: 80,
        };
        let response = filter.ip_filter(&request);
        assert_eq!(response.new_dst_ip, None);

        // Should be blocked because of port
        let request = IpFilterRequest {
            src_ip: Ipv4Addr::new(192, 168, 2, 1),
            dst_ip: Ipv4Addr::new(123, 123, 123, 123),
            src_port: 1234,
            dst_port: 22,
        };
        let response = filter.ip_filter(&request);
        assert_eq!(response.new_dst_ip, Some(Ipv4Addr::UNSPECIFIED));
    }
}
