use std::net::Ipv4Addr;

use etherparse::Ethernet2Header;
use etherparse::SlicedPacket;

use crate::constants::MY_MAC;
use crate::context::AppContextRef;
use crate::types::OutputMode;

pub fn handle_arp(ctx: AppContextRef, buf: &[u8]) -> (OutputMode, Option<Vec<u8>>) {
    let packet = SlicedPacket::from_ethernet(buf).unwrap();
    let arp = packet.payload;

    // Parse the ARP header
    // (Interface tap10 is asking for the MAC address of a host on the outside world)
    let header_eth_ipv4 = [00, 01, 08, 00, 06, 04, 00, 01];
    if arp[0..8] != header_eth_ipv4 {
        warn!("Unsupported ARP header (not ethernet/IPv4 request)");
        return (OutputMode::DROP, None);
    }
    let sha = [arp[8], arp[9], arp[10], arp[11], arp[12], arp[13]];
    let spa = [arp[14], arp[15], arp[16], arp[17]];
    let tha = [arp[18], arp[19], arp[20], arp[21], arp[22], arp[23]];
    let tpa = [arp[24], arp[25], arp[26], arp[27]];
    debug!("SHA: {:02x?}", sha);
    debug!("SPA: {:?}", spa);
    debug!("THA: {:02x?}", tha);
    debug!("TPA: {:0?}", tpa);
    if spa == tpa {
        debug!("ARP request for self, ignoring");
        return (OutputMode::DROP, None);
    }

    let output_eth;
    let output_arp;
    if spa == [10, 0, 0, 1] && tpa[0] == 10 {
        // Find the MAC address of the host in routes
        let routes = ctx.routes.read().unwrap();
        let route = routes.get_route(Ipv4Addr::from(tpa));
        if route.is_none() {
            warn!("No route found for host {:0?}", tpa);
            return (OutputMode::DROP, None);
        }
        let new_tha = route.unwrap().mac;
        output_eth = Ethernet2Header {
            destination: sha,
            source: MY_MAC,
            ether_type: 0x0806,
        };
        output_arp = [
            0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x02, // Header
            new_tha[0], new_tha[1], new_tha[2], new_tha[3], new_tha[4], new_tha[5], // THA
            tpa[0], tpa[1], tpa[2], tpa[3], // TPA
            sha[0], sha[1], sha[2], sha[3], sha[4], sha[5], // SHA
            spa[0], spa[1], spa[2], spa[3], // SPA
        ];
    } else {
        let mut new_sha = MY_MAC;
        if sha != MY_MAC {
            new_sha[5] = sha[5];
        }
        output_eth = Ethernet2Header {
            destination: sha,
            source: new_sha,
            ether_type: 0x0806,
        };
        output_arp = [
            0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x02, // Header
            new_sha[0], new_sha[1], new_sha[2], new_sha[3], new_sha[4], new_sha[5], // SHA
            tpa[0], tpa[1], tpa[2], tpa[3], // TPA
            tha[0], tha[1], tha[2], tha[3], tha[4], tha[5], // THA
            spa[0], spa[1], spa[2], spa[3], // SPA
        ];
    }
    let mut output = Vec::new();
    output.extend_from_slice(&output_eth.to_bytes());
    output.extend_from_slice(&output_arp);
    return (OutputMode::REPLY, Some(output));
}
