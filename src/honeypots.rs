use std::net::Ipv4Addr;

use async_tun::result::Result;
use docker_api::{
    models::{ContainerInspect200Response, ContainerSummary},
    opts::ContainerCreateOpts,
    ApiVersion, Docker,
};

use crate::{config::Honeypot, context::AppContextRef};

fn add_redirect(ctx: AppContextRef, ip: Ipv4Addr, honeypot: &Honeypot) {
    for redirect in &mut ctx.config.write().unwrap().filters.redirect {
        if let Some(to_honeypot) = &redirect.to_honeypot {
            if to_honeypot.eq(&honeypot.name) {
                warn!("Honeypot '{}' active with IP {}", honeypot.name, ip);
                redirect.to_ip = Some(ip);
            }
        }
    }
}

fn add_redirect_container_summary(
    ctx: AppContextRef,
    container: &ContainerSummary,
    honeypot: &Honeypot,
) {
    let networks = container
        .network_settings
        .as_ref()
        .unwrap()
        .networks
        .as_ref()
        .unwrap();
    let ip = networks.get("bridge").and_then(|n| n.ip_address.as_ref());
    return add_redirect(ctx, ip.unwrap().parse().unwrap(), honeypot);
}

fn add_redirect_inspect(
    ctx: AppContextRef,
    container: &ContainerInspect200Response,
    honeypot: &Honeypot,
) {
    let networks = container
        .network_settings
        .as_ref()
        .unwrap()
        .networks
        .as_ref()
        .unwrap();
    let ip = networks.get("bridge").and_then(|n| n.ip_address.as_ref());
    return add_redirect(ctx, ip.unwrap().parse().unwrap(), honeypot);
}

pub async fn setup_honeypots(ctx: AppContextRef) -> Result<()> {
    let docker = Docker::new_versioned(
        "unix:///var/run/docker.sock",
        ApiVersion::new(1, Some(41), None),
    )
    .or_else(|e| {
        error!("Could not connect to docker daemon: {}", e);
        Err(e)
    })?;

    let containers = docker
        .containers()
        .list(&Default::default())
        .await
        .or_else(|e| {
            error!("Could not connect to docker daemon: {}", e);
            Err(e)
        })?;

    let honeypots = ctx.config.read().unwrap().honeypots.clone();
    for honeypot in honeypots.iter() {
        let mut found = false;
        for container in &containers {
            if let Some(names) = &container.names {
                for name in names {
                    if format!("/{}", honeypot.name).eq(name) {
                        found = true;
                        add_redirect_container_summary(ctx.clone(), container, honeypot);
                        break;
                    }
                }
            }
        }
        if !found {
            error!("Starting honeypot {}", honeypot.name);
            let mut opts = ContainerCreateOpts::builder()
                .name(honeypot.name.clone())
                .image(honeypot.docker_image.clone())
                .tty(true)
                .publish_all_ports()
                .auto_remove(true);
            if !honeypot.command.is_empty() {
                opts = opts.command(honeypot.command.clone());
            }
            let container = docker.containers().create(&opts.build()).await?;
            container.start().await?;
            let container_info = container.inspect().await?;
            add_redirect_inspect(ctx.clone(), &container_info, honeypot);
        }
    }

    return Ok(());
}
