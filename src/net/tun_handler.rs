use async_std::fs::File;
use async_std::future;
use async_std::io::BufReader;
use async_std::prelude::*;
use async_std::task;
use async_std::task::JoinHandle;
use async_tun::result::Result;
use async_tun::Tun;
use std::io::Write;
use std::os::unix::prelude::AsRawFd;
use std::os::unix::prelude::FromRawFd;
use std::sync::Arc;
use std::time::Duration;

use crate::context::AppContextRef;
use crate::net::parse_packet::parse_packet;
use crate::types::OutputMode;

/// Read from the tun interface, process the packet and write to the file
pub fn create_handler(
    ctx: AppContextRef,
    inside: bool,
    read_file: File,
    mut write_file: std::fs::File,
    mut write_file_reply: std::fs::File,
) -> JoinHandle<Result<()>> {
    return task::spawn(async move {
        let mut reader = BufReader::new(read_file);
        let mut buf = [0u8; 1500];
        loop {
            let read_future = reader.read(&mut buf);
            let result = future::timeout(Duration::from_millis(500), read_future).await;
            match result {
                Ok(n) => {
                    info!(
                        "{} - reading {} bytes",
                        if inside {
                            "->  Packet from inside"
                        } else {
                            "-<  Packet from outside"
                        },
                        n.unwrap()
                    );
                    // let mut my_ctx = ctx.lock().unwrap();
                    // &mut *my_ctx
                    let (output_mode, result) = parse_packet(ctx.clone(), inside, &buf);
                    info!("");
                    if output_mode == OutputMode::FORWARD {
                        let res_u = result.unwrap();
                        write_file.write_all(&res_u).unwrap_or_else(|e| {
                            info!("Error writing: {:?}", e);
                        });
                        write_file.flush().unwrap_or_else(|e| {
                            info!("Error flushing: {:?}", e);
                        });
                    } else if output_mode == OutputMode::REPLY {
                        let res_u = result.unwrap();
                        write_file_reply.write_all(&res_u).unwrap_or_else(|e| {
                            info!("Error writing: {:?}", e);
                        });
                        write_file_reply.flush().unwrap_or_else(|e| {
                            info!("Error flushing: {:?}", e);
                        });
                    }
                }
                Err(_) => {}
            }
        }
    });
}

/// Create two handlers, one for each tun interface
pub async fn create_handlers(ctx: &mut AppContextRef, tun_in: Tun, tun_out: Tun) -> Result<()> {
    unsafe {
        let tun_in_write1 = std::fs::File::from_raw_fd(tun_in.as_raw_fd());
        let tun_in_write2 = std::fs::File::from_raw_fd(tun_in.as_raw_fd());
        let tun_in_read = File::from_raw_fd(tun_in.as_raw_fd());
        let tun_out_write1 = std::fs::File::from_raw_fd(tun_out.as_raw_fd());
        let tun_out_write2 = std::fs::File::from_raw_fd(tun_out.as_raw_fd());
        let tun_out_read = File::from_raw_fd(tun_out.as_raw_fd());

        let f1 = create_handler(
            Arc::clone(ctx),
            true,
            tun_in_read,
            tun_out_write1,
            tun_in_write2,
        );
        let f2 = create_handler(
            Arc::clone(ctx),
            false,
            tun_out_read,
            tun_in_write1,
            tun_out_write2,
        );

        f1.await?;
        f2.await?;
    }
    Ok(())
}
