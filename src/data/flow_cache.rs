use std::{
    collections::{hash_map::DefaultHasher, HashMap},
    hash::Hash,
    hash::Hasher,
    net::Ipv4Addr,
    time::SystemTime,
};

use etherparse::TcpHeaderSlice;

#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub enum FlowProtocol {
    TCP,
    UDP,
    ICMP,
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum TcpState {
    None,
    SynSent,
    SynAckReceived,
    Established,
    Closed,
}

#[derive(Clone, Copy, Debug)]
pub struct FlowEntry {
    pub flow_id: u64,
    pub src_ip: Ipv4Addr,
    pub dst_ip: Ipv4Addr,
    pub middlebox_ip: Ipv4Addr,
    pub protocol: FlowProtocol,
    pub src_port: u16,
    pub dst_port: u16,
    pub timestamp_started: SystemTime,
    pub timestamp_last: SystemTime,
    pub packets_in: u64,
    pub bytes_in: u64,
    pub packets_out: u64,
    pub bytes_out: u64,
    pub tcp_state: TcpState,
}

impl FlowEntry {
    pub fn generate_id(
        src_ip: Ipv4Addr,
        dst_ip: Ipv4Addr,
        protocol: FlowProtocol,
        src_port: u16,
        dst_port: u16,
    ) -> u64 {
        let mut hasher = DefaultHasher::new();
        src_ip.hash(&mut hasher);
        dst_ip.hash(&mut hasher);
        protocol.hash(&mut hasher);
        src_port.hash(&mut hasher);
        dst_port.hash(&mut hasher);
        hasher.finish()
    }

    pub fn new(
        flow_id: u64,
        src_ip: Ipv4Addr,
        dst_ip: Ipv4Addr,
        middlebox_ip: Ipv4Addr,
        protocol: FlowProtocol,
        src_port: u16,
        dst_port: u16,
    ) -> FlowEntry {
        let timestamp = SystemTime::now();
        FlowEntry {
            flow_id: flow_id,
            src_ip: src_ip,
            dst_ip: dst_ip,
            middlebox_ip: middlebox_ip,
            protocol: protocol,
            src_port: src_port,
            dst_port: dst_port,
            timestamp_started: timestamp,
            timestamp_last: timestamp,
            packets_in: 0,
            bytes_in: 0,
            packets_out: 0,
            bytes_out: 0,
            tcp_state: TcpState::None,
        }
    }

    pub fn update(&mut self, outbound: bool, len: usize) {
        self.timestamp_last = SystemTime::now();
        if outbound {
            self.packets_out += 1;
            self.bytes_out += len as u64;
        } else {
            self.packets_in += 1;
            self.bytes_in += len as u64;
        }
    }
}

#[derive(Debug)]
pub struct FlowCache {
    pub flows: HashMap<u64, FlowEntry>,
}

impl FlowCache {
    pub fn new() -> FlowCache {
        FlowCache {
            flows: HashMap::new(),
        }
    }

    pub fn add_flow(&mut self, flow: FlowEntry) {
        self.flows.insert(flow.flow_id, flow);
    }

    pub fn get_flow(&self, flow_id: u64) -> Option<&FlowEntry> {
        self.flows.get(&flow_id)
    }

    pub fn get_flow_mut(&mut self, flow_id: u64) -> Option<&mut FlowEntry> {
        self.flows.get_mut(&flow_id)
    }

    pub fn log_packet(
        &mut self,
        outbound: bool,
        src_ip: Ipv4Addr,
        dst_ip: Ipv4Addr,
        middlebox_ip: Ipv4Addr,
        protocol: FlowProtocol,
        src_port: u16,
        dst_port: u16,
        len: usize,
    ) {
        let flow_id = FlowEntry::generate_id(src_ip, dst_ip, protocol, src_port, dst_port);
        if let Some(flow) = self.get_flow_mut(flow_id) {
            flow.update(outbound, len);
        } else {
            let mut flow = FlowEntry::new(
                flow_id,
                src_ip,
                dst_ip,
                middlebox_ip,
                protocol,
                src_port,
                dst_port,
            );
            flow.update(outbound, len);
            self.add_flow(flow);
        }
    }

    pub fn log_tcp(
        &mut self,
        outbound: bool,
        src_ip: Ipv4Addr,
        dst_ip: Ipv4Addr,
        src_port: u16,
        dst_port: u16,
        tcp_header: &TcpHeaderSlice,
    ) {
        let (src_port, dst_port) = if outbound {
            (src_port, dst_port)
        } else {
            (dst_port, src_port)
        };
        let flow_id = FlowEntry::generate_id(src_ip, dst_ip, FlowProtocol::TCP, src_port, dst_port);
        if let Some(flow) = self.get_flow_mut(flow_id) {
            print!("TCP state: {:?} -> ", flow.tcp_state);
            if flow.tcp_state == TcpState::None {
                if tcp_header.syn() && !tcp_header.ack() {
                    flow.tcp_state = TcpState::SynSent;
                }
            } else if flow.tcp_state == TcpState::SynSent {
                if tcp_header.syn() && tcp_header.ack() {
                    flow.tcp_state = TcpState::SynAckReceived;
                }
            } else if flow.tcp_state == TcpState::SynAckReceived {
                if !tcp_header.syn() && tcp_header.ack() {
                    flow.tcp_state = TcpState::Established;
                }
            } else if flow.tcp_state == TcpState::Established {
                if tcp_header.fin() {
                    flow.tcp_state = TcpState::Closed;
                }
            } else if flow.tcp_state == TcpState::Closed {
                if tcp_header.syn() && !tcp_header.ack() {
                    flow.tcp_state = TcpState::SynSent;
                }
            }
            println!("{:?}", flow.tcp_state);
        }
        // self.print_flows();
    }

    pub fn print_flows(&self) {
        print!("{}[2J", 27 as char);
        println!("=== FLOWS ===");
        for (_, flow) in self.flows.iter() {
            println!(
                "  {}:{} -> ({}) -> {}:{}",
                flow.src_ip, flow.src_port, flow.middlebox_ip, flow.dst_ip, flow.dst_port
            );
            print!("  Packets In: {}", flow.packets_in);
            print!("  Bytes In: {}", flow.bytes_in);
            print!("  Packets Out: {}", flow.packets_out);
            print!("  Bytes Out: {}", flow.bytes_out);
            println!("  TCP State: {:?}", flow.tcp_state);
        }
        println!("=============");
    }

    pub fn iter(&self) -> std::collections::hash_map::Iter<u64, FlowEntry> {
        self.flows.iter()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_flow_cache() {
        let mut flow_cache = FlowCache::new();
        let flow_id = FlowEntry::generate_id(
            Ipv4Addr::new(192, 168, 1, 1),
            Ipv4Addr::new(192, 168, 1, 2),
            FlowProtocol::TCP,
            1234,
            80,
        );
        let flow = FlowEntry::new(
            flow_id,
            Ipv4Addr::new(192, 168, 1, 1),
            Ipv4Addr::new(192, 168, 1, 2),
            Ipv4Addr::new(192, 168, 1, 3),
            FlowProtocol::TCP,
            1234,
            80,
        );
        flow_cache.add_flow(flow);
        let flow = flow_cache.get_flow(flow_id).unwrap();
        assert_eq!(flow.src_ip, Ipv4Addr::new(192, 168, 1, 1));
        assert_eq!(flow.dst_ip, Ipv4Addr::new(192, 168, 1, 2));
        assert_eq!(flow.middlebox_ip, Ipv4Addr::new(192, 168, 1, 3));
        assert_eq!(flow.protocol, FlowProtocol::TCP);
        assert_eq!(flow.src_port, 1234);
        assert_eq!(flow.dst_port, 80);
        assert_eq!(flow.packets_in, 0);
        assert_eq!(flow.bytes_in, 0);
        assert_eq!(flow.packets_out, 0);
        assert_eq!(flow.bytes_out, 0);
        let flow = flow_cache.get_flow_mut(flow_id).unwrap();
        flow.update(true, 100);
        assert_eq!(flow.packets_in, 0);
        assert_eq!(flow.bytes_in, 0);
        assert_eq!(flow.packets_out, 1);
        assert_eq!(flow.bytes_out, 100);
        flow.update(false, 200);
        assert_eq!(flow.packets_in, 1);
        assert_eq!(flow.bytes_in, 200);
        assert_eq!(flow.packets_out, 1);
        assert_eq!(flow.bytes_out, 100);
    }
}
