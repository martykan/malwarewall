use std::net::Ipv4Addr;
use std::time::Duration;

use crate::context::AppContextRef;

use super::{CommonFilterModule, FilterModule, IpFilterModule, IpFilterRequest, IpFilterResponse};

pub struct RateLimit {
    ctx: AppContextRef,
}

impl RateLimit {
    pub fn new(ctx: AppContextRef) -> Box<RateLimit> {
        return Box::new(RateLimit { ctx: ctx });
    }

    pub fn new_module(ctx: AppContextRef) -> FilterModule {
        return FilterModule::Ip(RateLimit::new(ctx));
    }
}

impl CommonFilterModule for RateLimit {}

impl IpFilterModule for RateLimit {
    fn ip_filter(&self, request: &IpFilterRequest) -> IpFilterResponse {
        let mut drop = false;
        let mut matches_same_src = 0;
        let mut matches_same_src_port = 0;
        let mut matches_same_src_dst = 0;

        if let Some(rate_limit_config) = &self.ctx.config.read().unwrap().filters.rate_limit {
            for (_, flow) in self.ctx.flow_cache.read().unwrap().iter() {
                if flow.timestamp_last.elapsed().unwrap()
                    > Duration::from_millis(rate_limit_config.period)
                {
                    continue;
                }
                if flow.src_ip == request.src_ip {
                    matches_same_src += 1;
                    if flow.src_port == request.src_port {
                        matches_same_src_port += 1;
                    }
                    if flow.dst_ip == request.dst_ip {
                        matches_same_src_dst += 1;
                    }
                }
            }

            if matches_same_src > rate_limit_config.host_connections
                || matches_same_src_port > rate_limit_config.host_port_connections
                || matches_same_src_dst > rate_limit_config.host_dst_connections
            {
                drop = true;
            }
        }

        return IpFilterResponse {
            new_dst_ip: if drop {
                Some(Ipv4Addr::UNSPECIFIED)
            } else {
                None
            },
            ..Default::default()
        };
    }
}

#[cfg(test)]
mod tests {
    use std::net::Ipv4Addr;
    use std::time::{Duration, SystemTime};

    use crate::config::Config;
    use crate::context::AppContext;
    use crate::data::flow_cache::{FlowCache, FlowEntry, FlowProtocol};
    use crate::handlers::rate_limit::RateLimit;
    use crate::handlers::{IpFilterModule, IpFilterRequest};

    // Define some constants for the tests
    const SRC_IP: Ipv4Addr = Ipv4Addr::new(192, 168, 1, 1);
    const DST_IP: Ipv4Addr = Ipv4Addr::new(10, 0, 0, 1);
    const SRC_PORT: u16 = 1234;
    const DST_PORT: u16 = 80;

    #[test]
    fn test_rate_limit_no_config() {
        // Test that rate limiting does not occur if no rate limit config is present

        // Create a context with no rate limit config
        let config = Config::default();
        let ctx = AppContext::new(config);
        let rate_limit = RateLimit::new(ctx.clone());

        // Create a request
        let request = IpFilterRequest {
            src_ip: SRC_IP,
            dst_ip: DST_IP,
            src_port: SRC_PORT,
            dst_port: DST_PORT,
        };

        // Call the rate limiter and check that it returns the expected response
        let response = rate_limit.ip_filter(&request);
        assert_eq!(response.new_dst_ip, None);
    }

    #[test]
    fn test_rate_limit_below_limit() {
        // Test that rate limiting does not occur when below the limit

        // Create a context with a rate limit config
        let config = Config {
            filters: crate::config::Filters {
                rate_limit: Some(crate::config::RateLimit {
                    period: 1000,
                    host_connections: 2,
                    host_port_connections: 2,
                    host_dst_connections: 2,
                }),
                ..Default::default()
            },
        };
        let ctx = AppContext::new(config);
        let rate_limit = RateLimit::new(ctx.clone());

        // Create a flow cache with some active flows that do not exceed the limit
        let mut flow_entry = FlowEntry::new(
            FlowEntry::generate_id(SRC_IP, DST_IP, FlowProtocol::TCP, SRC_PORT, DST_PORT),
            SRC_IP,
            DST_IP,
            Ipv4Addr::UNSPECIFIED,
            FlowProtocol::TCP,
            SRC_PORT,
            DST_PORT,
        );
        flow_entry.timestamp_last = SystemTime::now() - Duration::from_millis(500);
        ctx.flow_cache.write().unwrap().add_flow(flow_entry);

        // Create a request
        let request = IpFilterRequest {
            src_ip: SRC_IP,
            dst_ip: DST_IP,
            src_port: SRC_PORT,
            dst_port: DST_PORT,
        };

        // Call the rate limiter and check that it returns the expected response
        let response = rate_limit.ip_filter(&request);
        assert_eq!(response.new_dst_ip, None);
    }

    #[test]
    fn test_rate_limit_exceed_host_connections() {
        // Test that rate limiting occurs when the number of connections from the same host exceeds the limit

        // Create a context with a rate limit config
        let config = Config {
            filters: crate::config::Filters {
                rate_limit: Some(crate::config::RateLimit {
                    period: 1000,
                    host_connections: 2,
                    host_port_connections: 2,
                    host_dst_connections: 2,
                }),
                ..Default::default()
            },
        };
        let ctx = AppContext::new(config);
        let rate_limit = RateLimit::new(ctx.clone());

        // Create a flow cache with some active flows that exceed the limit for connections from the same host
        let mut flow1 = FlowEntry::new(
            FlowEntry::generate_id(SRC_IP, DST_IP, FlowProtocol::TCP, SRC_PORT, DST_PORT),
            SRC_IP,
            DST_IP,
            Ipv4Addr::UNSPECIFIED,
            FlowProtocol::TCP,
            SRC_PORT,
            DST_PORT,
        );
        flow1.timestamp_last = SystemTime::now() - Duration::from_millis(500);

        let mut flow2 = FlowEntry::new(
            FlowEntry::generate_id(SRC_IP, DST_IP, FlowProtocol::TCP, SRC_PORT + 1, DST_PORT),
            SRC_IP,
            DST_IP,
            Ipv4Addr::UNSPECIFIED,
            FlowProtocol::TCP,
            SRC_PORT + 1,
            DST_PORT,
        );
        flow2.timestamp_last = SystemTime::now() - Duration::from_millis(500);

        let mut flow3 = FlowEntry::new(
            FlowEntry::generate_id(
                SRC_IP,
                DST_IP,
                FlowProtocol::TCP,
                SRC_PORT + 1,
                DST_PORT + 2,
            ),
            SRC_IP,
            DST_IP,
            Ipv4Addr::UNSPECIFIED,
            FlowProtocol::TCP,
            SRC_PORT + 1,
            DST_PORT + 2,
        );
        flow3.timestamp_last = SystemTime::now() - Duration::from_millis(500);
        ctx.flow_cache.write().unwrap().add_flow(flow1);
        ctx.flow_cache.write().unwrap().add_flow(flow2);
        ctx.flow_cache.write().unwrap().add_flow(flow3);

        // Create a request
        let request = IpFilterRequest {
            src_ip: SRC_IP,
            dst_ip: DST_IP,
            src_port: SRC_PORT + 3,
            dst_port: DST_PORT,
        };

        // Call the rate limiter and check that it returns the expected response
        let response = rate_limit.ip_filter(&request);
        assert_eq!(response.new_dst_ip, Some(Ipv4Addr::UNSPECIFIED));
    }
}
