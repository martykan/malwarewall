use cidr::Ipv4Inet;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::prelude::*;
use std::net::Ipv4Addr;

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone, Default)]
pub struct Config {
    pub filters: Filters,
    #[serde(default)]
    pub honeypots: Vec<Honeypot>,
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct Filters {
    #[serde(default)]
    pub filterlist: Vec<Filter>,
    #[serde(default)]
    pub redirect: Vec<Redirect>,
    pub rate_limit: Option<RateLimit>,
    pub suricata: Option<Suricata>,
    #[serde(default)]
    pub dns: Vec<DnsFilter>,
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct Filter {
    #[serde(default = "Filter::default_allow")]
    pub allow: bool,
    #[serde(default = "Filter::default_ip")]
    pub ip: Ipv4Inet,
    #[serde(default)]
    pub port: Option<u16>,
}

impl Filter {
    pub fn default_allow() -> bool {
        false
    }

    pub fn default_ip() -> Ipv4Inet {
        Ipv4Inet::new(Ipv4Addr::new(0, 0, 0, 0), 0).unwrap()
    }
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct DnsFilter {
    pub regex: String,
    #[serde(default = "DnsFilter::default_allow")]
    pub allow: bool,
}

impl DnsFilter {
    pub fn default_allow() -> bool {
        false
    }
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct Redirect {
    #[serde(default = "Redirect::default_ip")]
    pub from_ip: Ipv4Inet,
    pub from_port: Option<u16>,
    pub from_src_port: Option<u16>,
    pub to_ip: Option<Ipv4Addr>,
    #[serde(default)]
    pub to_honeypot: Option<String>,
    pub to_port: Option<u16>,
    #[serde(default = "Redirect::default_chance")]
    pub chance: f32,
}

impl Redirect {
    pub fn default_ip() -> Ipv4Inet {
        Ipv4Inet::new(Ipv4Addr::new(0, 0, 0, 0), 0).unwrap()
    }
    pub fn default_chance() -> f32 {
        1.0
    }
}

impl Default for Redirect {
    fn default() -> Self {
        Redirect {
            from_ip: Redirect::default_ip(),
            from_port: None,
            from_src_port: None,
            to_ip: Some(Ipv4Addr::UNSPECIFIED),
            to_honeypot: None,
            to_port: None,
            chance: 1.0,
        }
    }
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct RateLimit {
    pub period: u64,
    pub host_connections: u32,
    pub host_port_connections: u32,
    pub host_dst_connections: u32,
    pub tcp_period: u64,
    pub tcp_handshakes: u32,
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct Suricata {
    pub log_path: String,
}

#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
pub struct Honeypot {
    pub name: String,
    pub docker_image: String,
    #[serde(default)]
    pub command: Vec<String>,
}

impl Config {
    pub fn load(filename: &str) -> Config {
        let mut file = File::open(filename).unwrap();
        let mut contents = String::new();
        file.read_to_string(&mut contents).unwrap();

        let config: Config = serde_yaml::from_str(&contents).unwrap_or_else(|e| {
            panic!("Error parsing config file: {}", e);
        });
        debug!("{:#?}", config);
        for dns in &config.filters.dns {
            assert!(
                Regex::new(&dns.regex).is_ok(),
                "Invalid DNS regex: {}",
                dns.regex
            );
        }
        return config;
    }
}

impl Default for Filters {
    fn default() -> Self {
        Filters {
            filterlist: Vec::new(),
            redirect: Vec::new(),
            rate_limit: None,
            suricata: None,
            dns: Vec::new(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::net::Ipv4Addr;

    #[test]
    fn test_parse_config() {
        let yaml = r#"
filters:
  filterlist:
    - allow: true
      ip: 192.168.1.1/24
    - ip: 192.168.1.100
    - port: 22
  redirect:
    - from_ip: 8.8.8.8
      to_ip: 1.1.1.1
      chance: 0.5
  rate_limit:
    period: 10000
    host_connections: 20
    host_port_connections: 5
    host_dst_connections: 5
    tcp_period: 100
    tcp_handshakes: 1
  suricata:
    log_path: /var/log/suricata/eve.json
  dns:
    - regex: ".*\\.xyz"
      allow: false
    - regex: "(.*\\.)?vut(br)?\\.cz"
      allow: false
honeypots:
  - name: honeypots
    docker_image: justsky/honeypots
    command: ["--setup", "all"]
"#;

        let config: Config = serde_yaml::from_str(yaml).unwrap();

        let expected_honeypots = vec![Honeypot {
            name: "honeypots".to_string(),
            docker_image: "justsky/honeypots".to_string(),
            command: vec!["--setup".to_string(), "all".to_string()],
        }];
        assert_eq!(config.honeypots, expected_honeypots);

        let expected_filterlist = vec![
            Filter {
                allow: true,
                ip: Ipv4Inet::new(Ipv4Addr::new(192, 168, 1, 1), 24).unwrap(),
                port: None,
            },
            Filter {
                allow: false,
                ip: Ipv4Inet::new(Ipv4Addr::new(192, 168, 1, 100), 32).unwrap(),
                port: None,
            },
            Filter {
                allow: false,
                ip: Ipv4Inet::new(Ipv4Addr::new(0, 0, 0, 0), 0).unwrap(),
                port: Some(22),
            },
        ];
        assert_eq!(config.filters.filterlist, expected_filterlist);

        let expected_redirect = vec![Redirect {
            from_ip: Ipv4Inet::new(Ipv4Addr::new(8, 8, 8, 8), 32).unwrap(),
            to_ip: Some(Ipv4Addr::new(1, 1, 1, 1)),
            chance: 0.5,
            ..Default::default()
        }];
        assert_eq!(config.filters.redirect, expected_redirect);

        let expected_rate_limit = RateLimit {
            period: 10000,
            host_connections: 20,
            host_port_connections: 5,
            host_dst_connections: 5,
            tcp_period: 100,
            tcp_handshakes: 1,
        };
        assert_eq!(config.filters.rate_limit.unwrap(), expected_rate_limit);

        let expected_suricata = Suricata {
            log_path: "/var/log/suricata/eve.json".to_string(),
        };
        assert_eq!(config.filters.suricata.unwrap(), expected_suricata);

        let expected_dns = vec![
            DnsFilter {
                regex: ".*\\.xyz".to_string(),
                allow: false,
            },
            DnsFilter {
                regex: "(.*\\.)?vut(br)?\\.cz".to_string(),
                allow: false,
            },
        ];
        assert_eq!(config.filters.dns, expected_dns);
    }

    #[test]
    fn test_parse_config_empty() {
        let yaml = r#"
filters:
"#;
        let config: Config = serde_yaml::from_str(yaml).unwrap();
        assert_eq!(config.filters.filterlist.len(), 0);
        assert_eq!(config.filters.redirect.len(), 0);
        assert_eq!(config.filters.rate_limit, None);
    }
}
